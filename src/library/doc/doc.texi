\input texinfo
@documentlanguage en
@settitle Bolt Plugin API Reference

@copying
This is the API reference manual for version 1.0 of Bolt Launcher's
Lua-based plugin loader. Bolt Launcher is free and open-source software.
The software itself, including by association all parts of its plugin
loader, are licensed under AGPL-3.

Copyright @copyright{} 2024 Adamcake

@quotation
Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.
@end quotation
@end copying

@titlepage
@title Bolt Plugin API Reference
@author Adamcake
@page
@vskip 0pt plus 1filll
@ifplaintext
@insertcopying
@end ifplaintext
@end titlepage

@macro eventhandler {eventtype, reference}
Sets an event handler for \eventtype\. The function will overwrite any
previous event handler, or, if it's not a function, then any previous
event handler will be deleted. See \reference\ for documentation on
this event object.
@end macro

@macro windoweventhandler {wtype, eventtype, reference}
Sets an event handler for this \wtype\ for \eventtype\. The function
will overwrite any previous event handler, or, if it's not a function,
then any previous event handler will be deleted. See \reference\ for
documentation on this event object.
@end macro

@macro browserjavascriptevents {}
The appropriate JavaScript events will also be sent internally to the
browser; plugins don't need to handle this event from Lua in order to
implement any browser functionality.
@end macro

@macro eventobjectwarning {}
It's @strong{not safe} to use an event object after the event handler
has returned.
@end macro

@macro bufferapifooter {}
@xref{objects-buffer} for more on the buffer API.
@end macro

@macro customshaderapifooter {t}
This \t\ is part of the @ref{appendix-custom-shaders}, which requires
some understanding of shader programming to be able to use.
@end macro

@node Top
@top Bolt Plugin API Reference

This is the API reference manual for version 1.0 of Bolt Launcher's API
for Lua plugins. All of the available functions and types are listed
along with a simple usage example.

This document is for developers. If you're not looking to develop
plugins, you don't need to read this document.

@summarycontents

@node Introduction
@chapter Introduction

Bolt Launcher comes with a built-in plugin loader. A plugin loader is
not the same thing as plugins - the loader is what enables plugins to
be able to work, but it doesn't have any plugins built into it in
itself. Plugins can be made by anyone and must be obtained separately
from Bolt. This document details how to make your own Bolt plugins.

Plugins are written in Lua, but the plugin loader itself is a dynamic
library written in C. The launcher launches the game and loads the
library into the process using a manual map injector after the process
loads but before allowing it to run. When the library starts up, it
modifies the import table of the process to insert function hooks. If
that's all too technical for you, don't worry: you don't need to
understand any of that to be able to write plugins, but just know that
your Lua code runs directly inside the game process.

The word "inject" sounds scary, but Bolt is totally harmless: the
technique described above is the same one used by lots of software you
might already be using, such as OBS, Alt1@sup{1}, steam overlay, Discord
screencapture, or obs-vkcapture. Like those, Bolt only hooks external
graphics-related functions and will never attempt to read or modify the
game code, therefore it is entirely allowed under the terms of service
and will not trip any known anti-cheating measures@sup{2}. It does,
however, mean that it's less powerful than a tool like Runelite, since
the only information it has access to is what's available in the OpenGL
shaders; for example, it can see the vertex data and texture data of an
item being rendered, but cannot know the item ID.

(@sup{1} Yes, really.)

(@sup{2} That is NOT to claim that Bolt is undetectable. It's not -
nothing is.)

@node Getting Started
@chapter Getting Started

The primary file in a plugin is called "bolt.json". It needs to have
that exact name, in lower-case. Here's how your bolt.json might look:

@example json
@verbatim
{
  "name": "Goblin Helper",
  "version": "1.0",
  "description": "A plugin designed to help you kill goblins more effectively and display a graph of your GSE (goblin-slaughter efficiency)",
  "main": "main.lua"
}
@end verbatim
@end example

The directory that contains bolt.json is called the "plugin directory".
As a general rule, the plugin only has access to files inside the plugin
directory, and any file paths will be considered relative to the plugin
directory.

There are no limitations on the text contents or length of the  name,
version, or description, and the version and description are optional.
That said, it's suggested to use a short name (2-3 words), a longer and
helpful description, and a sensible system of version numbers.

The "main" file, in this case "main.lua", is the file that will be
loaded and run when a user starts your plugin. This file will be loaded
from the root of the plugin directory, next to bolt.json. If your main
file is in a subdirectory then you need to write the relative path using
'/' as directory separators, e.g. "app/src/main.lua".

Here's an example of a simple main.lua file. Lines beginning with
@verb{|--|} are comments in Lua.

@example lua
@verbatim
-- load the Bolt API
local bolt = require("bolt")

-- make sure this plugin is running on a Bolt version compatible with
-- the one it was written for (1.0)
bolt.checkversion(1, 0)

-- some variables we'll refer to later
local interval = 1000 * 1000
local clickcount = 0
local nextprinttime = bolt.time() + interval

-- set a function that will run every time the user clicks the game
-- window (excluding the title bar or any decorations) with the left,
-- middle, or right mouse button
bolt.onmousebutton(function (event)
  -- check if this is a left click using the event's button() function,
  -- and if it is, count it
  if event:button() == 1 then
    clickcount = clickcount + 1
  end
end)

-- set a function that will run every time SwapBuffers is called - in
-- other words, this runs at the end of every frame, so around 100 times
-- per second depending on the user's FPS
bolt.onswapbuffers(function (event)
  -- check if the time interval (1 second) has passed yet
  if bolt.time() >= nextprinttime then
    -- print a message
    print(string.format("clicks-per-second: %s", tostring(clickcount)))

    -- reset the click count and update the interval timer
    clickcount = 0
    nextprinttime = nextprinttime + interval
  end
end)
@end verbatim
@end example

As you can see, this is a simple plugin which keeps track of the user's
left-clicks per second and prints that information using Lua's built-in
"print" function. This prints to the terminal. If you don't have a
terminal open, you won't see anything, but the plugin is still running.
All of the functions used here are documented below.

Before we move on, there's a tiny but important detail of this code to
be aware of. Notice how functions like @code{bolt.checkversion} use a
'.', but @code{event:button()} uses a ':'. This is because @code{bolt}
is a simple list of functions, whereas @code{event} is a userdata object
which needs to be passed as the first argument to its functions - that's
true for all types of object in the Bolt API. In Lua, ':' is shorthand
for doing exactly that.

@node Updater URLs
@section Updater URLs

There are two ways to install a plugin via the plugin menu: the first is
a file picker which needs you to navigate to the "bolt.json" file on
your computer, assuming you've already downloaded or created a plugin.
The second way is to enter an updater URL and allow the plugin menu to
download the plugin onto your computer for you. For most users this is
far simpler as it only needs them to copy-paste a hyperlink into the
menu and press enter. Even more convenient is that this same URL will be
queried each time the user wants to check for a newer version of your
plugin, whereas there's no way to update-check a plugin that was
selected from the file picker.

Updater URLs return JSON which should look like this:

@example json
@verbatim
{
  "url": "https://bolt.adamcake.com/my-plugin-v1.0.1.zip",
  "version": "1.0.1",
  "sha256": "ec3791c5fcbd9b7f077ac292a2ea319f428e7023919d01e33ff118dcbbb29d16"
}
@end verbatim
@end example

When initially installing a plugin from an updater URL, the file at
"url" will be downloaded. Next, if the optional "sha256" is present, the
downloaded file is hashed and will be rejected if the checksums don't
match. The file contents will be extracted to a new directory in bolt's
data location, and "bolt.json" will then be selected from that location.

When checking for updates, the updater URL will be queried. If "sha256"
is present in the response and does not match the hash that was
previously installed, the plugin will be re-downloaded from "url",
hashed, and like before it will be rejected if the hash doesn't match
the sha256 string. If "sha256" is not present, it will instead compare
the "version" in the response to the version in the previously-installed
"bolt.json", and, if they're not an exact match, the plugin will be
re-downloaded on that basis. To clarify, "version" is completely
ignored if "sha256" is present - you only need one or the other. Either
way, after downloading the new version, it will be extracted to the same
location as it was installed previously, after deleting all previous
contents of that directory.

In the above example, the downloaded file is a .zip, but Bolt supports
every type of archive format that can be auto-detected by libarchive
(which is practically every format ever created.) If possible, consider
using a format like .tar.xz, which is slow to create but can be
extracted very quickly and has an extremely high compression ratio (i.e.
small download size), for the fastest possible user experience.
Generally speaking, .zip and .rar are the worst in both of these
aspects, but you can use them if you really want to.

Note that updater URLs and the "url" contained in them must respond with
a status of "200 OK", otherwise the plugin menu will not continue with
the process of installing/updating the plugin.

@node Functions
@chapter List of Functions

This is a list of all functions in @code{bolt}, the table returned by
@code{require("bolt")}.

@node functions-apiversion
@section apiversion

Returns the Bolt API major version and minor version, in that order.
Plugins should call this function on startup and, if the major version
is one it doesn't recognise, it should exit by calling `error()`. The
minor version however does not need to be checked, as minor versions
will never contain breaking changes; they may add features, though, and
the minor version can be used to check for the existence of those
features.

For compatibility reasons, there will never be a breaking change to this
function.

@example lua
@verbatim
local major, minor = bolt.apiversion()
@end verbatim
@end example

@node functions-checkversion
@section checkversion

A simple alternative to @ref{functions-apiversion} which calls error()
if either of these conditions is true:

@itemize @bullet
@item the first parameter is not equal to Bolt's major version
@item the second parameter is greater than Bolt's minor version
@end itemize

This function will never return on failure, since that's the
implementation of Lua's error() function. Calling error() in a Bolt
plugin will always be handled by stopping the plugin.

For compatibility reasons, there will never be a breaking change to this
function.

@example lua
@verbatim
bolt.checkversion(1, 0)
@end verbatim
@end example

@node functions-close
@section close

Stops this instance of this plugin. This is essentially the same as the
plugin being stopped via the plugin menu in the launcher.

@example lua
@verbatim
bolt.close()
@end verbatim
@end example

@node functions-time
@section time

Returns a monotonic time as an integer, in microseconds.

This function can be used for timing. The number it returns is arbitrary
- that is, it's the number of microseconds that have elapsed since an
arbitrary point in time - therefore it's not useful for anything other
than to call this function multiple times and compare the results.

Note that on a 32-bit CPU this number will overflow back to 0 every
~4296 seconds, which is slightly more than an hour. On a 64-bit CPU, it
will overflow every ~18 trillion seconds, or around 585 millennia.
Playing on a 32-bit CPU is therefore not advisable, but if a plugin
wishes to support 32-bit CPUs while using this function, it must handle
the possibility of time() resetting to 0.

@example lua
@verbatim
local t1 = bolt.time()
-- something time-consuming...
local t2 = bolt.time()
print(string.format("execution took %s Î¼s", tostring(t2 - t1)))
@end verbatim
@end example

@node functions-datetime
@section datetime

Returns six integers: the current calendar year, month (1-12), day
(1-31), hour (0-23), minute (0-59), and second (0-60@sup{1}), in
game-time (i.e. UTC). The time is based on the user's system clock but
the result will be converted to game-time. There is no way to get the
user's timezone information via Bolt.

Don't try to use this function for precision timing. Use time() instead.

@example lua
@verbatim
local year, month, day, hour, minute, second = bolt.datetime()
print(string.format(
  "the time is %s:%s:%s on %s-%s-%s",
  tostring(hour), tostring(minute), tostring(second),
  tostring(year), tostring(month), tostring(day)
))
@end verbatim
@end example

(@sup{1} seconds value can be 60 in the case of a leap-second)

@node functions-weekday
@section weekday

Returns an integer representing the current weekday in game-time (i.e.
UTC). A value of 1 represents Sunday, 2 represents Monday, 3 represents
Tuesday, and so on.

This function is based on the user's system clock but the result will be
converted to game-time. For example, if the user's system time is 22:00
EST on a monday, this function will return 3 (tuesday), because the
game-time is 03:00 on a tuesday. There is no way to get the user's
timezone information via Bolt.

@example lua
@verbatim
local function isweekend()
  local day = bolt.weekday()
  return day == 1 or day == 7
end
@end verbatim
@end example

@node functions-playerposition
@section playerposition

Returns a @ref{objects-point} representing the last known position of
the player, in world coordinates. This point relates to point (0,0,0) on
the player model, which is usually on the ground between the model's
feet during a normal standing animation. Also see
@ref{appendix-world-coordinates}.

@example lua
@verbatim
local worldpoint = bolt.playerposition()
@end verbatim
@end example

@node functions-gamewindowsize
@section gamewindowsize

Returns the last known width and height of the game window, in pixels.
Specifically this refers to the inner "graphical" area of the window,
excluding any OS-level decorations like borders or title bars.

@example lua
@verbatim
local width, height = bolt.gamewindowsize()
@end verbatim
@end example

@node functions-gameviewxywh
@section gameviewxywh

Returns the last known x, y, width and height of the game view inside
the game window, in pixels. The game view is the area where 3D rendering
of the game world takes place, which by default takes up the entire
window, but its position can be configured by the user in the game's
layout settings.

@example lua
@verbatim
local x, y, width, height = bolt.gameviewxywh()
@end verbatim
@end example

@node functions-flashwindow
@section flashwindow

Makes the game window "flash" to grab the user's attention until the
window is next brought into focus. If the window is already focused,
this function does nothing.

The exact behaviour of this function will depend on the user's platform
and window manager, but the most common result is for the taskbar icon
to flash orange.

@example lua
@verbatim
bolt.flashwindow()
@end verbatim
@end example

@node functions-isfocused
@section isfocused

Returns a boolean value indicating whether the game window is the
currently-focused window on the user's desktop.

@example lua
@verbatim
if bolt.isfocused() then
  -- ...
end
@end verbatim
@end example

@node functions-characterid
@section characterid

Returns a string which uniquely identifies the game character currently
being played. The string will contain only alphanumeric characters. The
same character will always have the same ID, even if the display name is
changed. It's also not possible to change characters without restarting
the game client, so there's no need to call this function more than once
per run of a plugin.

The value returned by this function is a hash, so it's not considered
sensitive in terms of account security, although users will still
appreciate their privacy being respected.

@example lua
@verbatim
local id = bolt.characterid()
@end verbatim
@end example

@node functions-loadfile
@section loadfile

Loads the file into a Lua string and returns it. The file will be
located relative to the plugin directory. Either '/' or '\' may be used
as file separators, regardless of OS, and it makes no difference if the
path does or doesn't start with a file separator. In the case of an
error, this function will return nil. The most likely cause of failure
is that the file doesn't exist.

The plugin directory is read-only. For writeable files, use
@ref{functions-saveconfig} and @ref{functions-loadconfig}.

@example lua
@verbatim
local filecontents = bolt.loadfile("data.bin")
@end verbatim
@end example

@node functions-loadconfig
@section loadconfig

Loads the file into a Lua string and returns it. The file will be
located relative to the plugin's config directory, the exact location of
which depends on the user's OS. Either '/' or '\' may be used as file
separators, regardless of OS, and it makes no difference if the path
does or doesn't start with a file separator. In the case of an error,
this function will return nil. The most likely cause of failure is that
the file doesn't exist.

@example lua
@verbatim
local filecontents = bolt.loadconfig("position.cfg")
@end verbatim
@end example

@node functions-saveconfig
@section saveconfig

Saves the Lua string in the second parameter into a file identified by
the first parameter. The file will be located relative to the plugin's
config directory, the exact location of which depends on the user's OS.
Either '/' or '\' may be used as file separators, regardless of OS, and
it makes no difference if the path does or doesn't start with a file
separator.

This function returns a boolean: if the file is saved successfully this
function will return true. If not, it will return false. The most likely
cause of failure is that the file already exists and is locked for
writing, such as by the user having it open in a text editor.

@example lua
@verbatim
bolt.saveconfig("info.bin", "Some example file contents")
@end verbatim
@end example

@node functions-createsurface
@section createsurface

Creates and returns a new @ref{objects-surface} with the given width and
height. The surface will initally be fully transparent.

@example lua
@verbatim
local mysurface = bolt.createsurface(800, 608)
@end verbatim
@end example

@node functions-createsurfacefromrgba
@section createsurfacefromrgba

Creates and returns a new @ref{objects-surface} with the given width,
height, and RGBA data. The data can be a string or a
@ref{objects-buffer}.

There are four bytes in an RGBA pixel, so the number of bytes in the
data is expected to be @code{4 * width * height}. If fewer bytes than
that are provided, the data will be padded with zeroes. If too many
bytes are provided, the excess data will be unused. The data will be
interpreted in row-major order with the first pixel being in the
top-left.

The following example creates a 2x2-pixel surface with a
diagonally-opposite pattern of black and white pixels.

@example lua
@verbatim
local blackpixel = "\x00\x00\x00\xFF"
local whitepixel = "\xFF\xFF\xFF\xFF"
local rgba = blackpixel .. whitepixel .. whitepixel .. blackpixel
local mysurface = bolt.createsurfacefromrgba(2, 2, rgba)
@end verbatim
@end example

@node functions-createsurfacefrompng
@section createsurfacefrompng

Creates and returns a new @ref{objects-surface} from
the PNG file at the given path. The first returned value is the surface
object and the second and third values are the width and height
respectively.

The path will be interpreted similarly to require(), i.e. relative to
the plugin directory, using '.' as file separators, and must not include
the ".png" extension (this is appended automatically). This function
will call `error()` if the file does not exist or is inaccessible for
any reason.

The surface will have the same width and height as the image. As with
@ref{functions-createsurface}, the width and height of your PNG file
should be integral powers of 2.

The following example creates a surface from "images/icon.png" relative
to the plugin directory.

@example lua
@verbatim
local mysurface, width, height = bolt.createsurfacefrompng("images.icon")
@end verbatim
@end example

@node functions-createwindow
@section createwindow

Creates and returns a new @ref{objects-window} with the given initial
values for x, y, width and height. The x and y relate to the top-left
corner of the game. Embedded windows can capture mouse and keyboard
events, and can be drawn onto like a @ref{objects-surface}.

The following example creates a window with its top-left corner 50px
from the left and 60px from the top of the game, with a width of 800 and
a height of 608. @ref{window-clear} is used to make the window entirely
red and opaque, otherwise it would be transparent.

@example lua
@verbatim
local mywindow = bolt.createwindow(50, 60, 800, 608)
mywindow:clear(1, 0, 0)
@end verbatim
@end example

@node functions-createbrowser
@section createbrowser

Creates and returns a new @ref{objects-browser} with the given initial
values for width, height, and URL. If the URL begins with "plugin://",
it will be interpreted as a file path relative to the plugin directory,
and must use '/' as file separators (if any). Otherwise, it will be
treated as a URL of an internet website. The same rules go for any
navigations or fetch requests made by the browser during its lifetime.

The optional 6th parameter is some javascript code which will be run in
an OnContextCreated callback. This is immediately after the V8 context
has been created, so the JavaScipt @code{window} object is available but
the DOM content is not yet loaded.

The following example shows an invocation without some custom JS
followed by one with some custom JS, to demonstrate that the parameter
is optional.

@example lua
@verbatim
local mybrowser = bolt.createwindow(800, 608, "https://bolt.adamcake.com")
local mybrowser = bolt.createwindow(800, 608, "https://bolt.adamcake.com", "window.myCustomFunction = (a, b) => a + b;")
@end verbatim
@end example

@node functions-createembeddedbrowser
@section createembeddedbrowser

Creates and returns a new @ref{objects-embeddedbrowser} with the given
initial values for x, y, width, height and URL. If the URL begins with
"plugin://", it will be interpreted as a file path relative to the
plugin directory, and must use '/' as file separators (if any).
Otherwise, it will be treated as a URL of an internet website. The same
rules go for any navigations or fetch requests made by the browser
during its lifetime.

The optional 6th parameter is some javascript code which will be run in
an OnContextCreated callback. This is immediately after the V8 context
has been created, so the JavaScipt @code{window} object is available but
the DOM content is not yet loaded.

The following example shows an invocation without some custom JS
followed by one with some custom JS, to demonstrate that the parameter
is optional.

@example lua
@verbatim
local mybrowser = bolt.createembeddedbrowser(50, 60, 800, 608, "https://bolt.adamcake.com")
local mybrowser = bolt.createembeddedbrowser(50, 60, 800, 608, "https://bolt.adamcake.com", "window.myCustomFunction = (a, b) => a + b;")
@end verbatim
@end example

@node functions-point
@section point

Creates and returns a new @ref{objects-point} from x, y and z values.
Point objects represent a point in 3D space, and have functions which
are useful for 3D space calculations.

@example lua
@verbatim
local mypoint = bolt.point(0, 0, 0)
@end verbatim
@end example

@node functions-createbuffer
@section createbuffer

Creates and returns a new @ref{objects-buffer} with the given size.
Buffer objects are fixed-size and useful for passing large amounts of
binary data to functions. They're mostly analogous to JavaScript's
@code{DataView}. The initial contents will be 0.

@example lua
@verbatim
local mybuffer = bolt.createbuffer(65536)
@end verbatim
@end example

@node functions-createvertexshader
@section createvertexshader

Compiles and returns a vertex shader from a string containing GLSL. If
the code fails to compile, this function will call @code{error()}.

The shader code must not contain a @code{#version} header. The string
@code{#version 330 core} will be prepended automatically to it.

@customshaderapifooter{function}

@example lua
@verbatim
local myvertshader = bolt.createvertexshader("void main() { gl_Position = vec4(0.0, 0.0, 0.0, 1.0); }")
@end verbatim
@end example

@node functions-createfragmentshader
@section createfragmentshader

Compiles and returns a fragment shader from a string containing GLSL. If
the code fails to compile, this function will call @code{error()}.

The shader code must not contain a @code{#version} header. The string
@code{#version 330 core} will be prepended automatically to it.

@customshaderapifooter{function}

@example lua
@verbatim
local myfragshader = bolt.createfragmentshader("out vec4 c; void main() { c = vec4(1.0); }")
@end verbatim
@end example

@node functions-createshaderprogram
@section createshaderprogram

Links and returns a @ref{objects-shaderprogram} using a vertex shader
and a fragment shader. If linking fails, this function will call
@code{error()}.

@customshaderapifooter{function}

@example lua
@verbatim
local myprogram = bolt.createshaderprogram(myvertshader, myfragshader)
@end verbatim
@end example

@node functions-createshaderbuffer
@section createshaderbuffer

Creates and returns a @ref{objects-shaderbuffer} with the given
contents. The data can be either a string or a @ref{objects-buffer}.

This function is not to be confused with @ref{functions-createbuffer}.
The difference is that Buffer objects exist in RAM and can be read from
or written to at any time. Shader Buffer objects exist in VRAM, cannot
be read from, and cannot be written to after creation, but can be used
to run custom shader programs.

@customshaderapifooter{function}

@example lua
@verbatim
local mybuf = bolt.createshaderbuffer("\x00\x00\x00\x00\x00\x00\x00\x00")
@end verbatim
@end example

@node functions-onrender2d
@section onrender2d

@eventhandler{2D rendering events, @ref{objects-batch2d}}

@example lua
@verbatim
bolt.onrender2d(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onrender3d
@section onrender3d

@eventhandler{3D rendering events, @ref{objects-render3d}}

@example lua
@verbatim
bolt.onrender3d(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onrenderparticles
@section onrenderparticles

@eventhandler{particle rendering events, @ref{objects-renderparticles}}

@example lua
@verbatim
bolt.onrenderparticles(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onrendericon
@section onrendericon

@eventhandler{icon rendering events, @ref{objects-rendericon}}

Unlike "big icons", the pre-rendered icons given by this callback are
stored for a long time, often indefinitely. This only seems to be used
for item icons. Icons are rendered at 64x64 resolution.

@example lua
@verbatim
bolt.onrendericon(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onrenderbigicon
@section onrenderbigicon

@eventhandler{icon rendering events, @ref{objects-rendericon}}

"big icons" are larger than normal icons, and, despite being
pre-rendered, each one seems to be used only once. Big icons are
rendered at 512x512 resolution. They're used for NPC chat-heads and some
specific UI elements.

@example lua
@verbatim
bolt.onrenderbigicon(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onminimapterrain
@section onminimapterrain

@eventhandler{minimap terrain events, @ref{objects-minimapterrain}}

@example lua
@verbatim
bolt.onminimapterrain(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onminimaprender2d
@section onminimaprender2d

@eventhandler{minimap render2d events, @ref{objects-batch2d}}

@example lua
@verbatim
bolt.onminimaprender2d(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onrenderminimap
@section onrenderminimap

@eventhandler{minimap-rendering events, @ref{objects-renderminimap}}

@example lua
@verbatim
bolt.onrenderminimap(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onswapbuffers
@section onswapbuffers

@eventhandler{swapbuffers events, @ref{objects-swapbuffers}}

This event is commonly used as a "sync point", i.e. to ensure that some
Lua code will run at regular intervals.

@example lua
@verbatim
bolt.onswapbuffers(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onmousemotion
@section onmousemotion

@eventhandler{mouse motion events, @ref{objects-mousemotion}}

This will fire only for mouse motion events that are received by the
game. Events received by a @ref{objects-window} or
@ref{objects-embeddedbrowser} will not be received by the game, so will
not fire this event.

@example lua
@verbatim
bolt.onmousemotion(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onmousebutton
@section onmousebutton

@eventhandler{mouse button events, @ref{objects-mousebutton}}

This handler runs immediately after a button is pressed down. When the
button is released, @ref{functions-onmousebuttonup} will run.

This will fire only for mouse button events that are received by the
game. Events received by a @ref{objects-window} or
@ref{objects-embeddedbrowser} will not be received by the game, so will
not fire this event.

@example lua
@verbatim
bolt.onmousebutton(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onmousebuttonup
@section onmousebuttonup

@eventhandler{mouse button-up events, @ref{objects-mousebutton}}

This handler runs immediately after a button is released. It shares the
same type of event object as @ref{functions-onmousebutton}.

This will fire only for mouse button events that are received by the
game. Events received by a @ref{objects-window} or
@ref{objects-embeddedbrowser} will not be received by the game, so will
not fire this event.

@example lua
@verbatim
bolt.onmousebuttonup(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-onscroll
@section onscroll

@eventhandler{mouse scroll events, @ref{objects-scroll}}

This will fire only for mouse scroll events that are received by the
game. Events received by @ref{objects-window} or
@ref{objects-embeddedbrowser} will not be received by the game, so will
not fire this event.

@example lua
@verbatim
bolt.onscroll(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node functions-buffergetint8
@section buffergetint8

Reads a single byte from a buffer object or string, at the given offset,
and returns it as a signed integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetint8(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetint16
@section buffergetint16

Reads a two-byte value from the buffer object or string, at the given
offset, and returns it as a signed integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetint16(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetint32
@section buffergetint32

Reads a four-byte value from the buffer object or string, at the given
offset, and returns it as a signed integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetint32(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetint64
@section buffergetint64

Reads an eight-byte value from the buffer object or string, at the given
offset, and returns it as a signed integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetint64(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetuint8
@section buffergetuint8

Reads a single byte from the buffer object or string, at the given
offset and returns it, as an unsigned integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetuint8(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetuint16
@section buffergetuint16

Reads a two-byte value from the buffer object or string, at the given
offset, and returns it as an unsigned integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetuint16(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetuint32
@section buffergetuint32

Reads a four-byte value from the buffer object or string, at the given
offset, and returns it as an unsigned integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetuint32(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetuint64
@section buffergetuint64

Reads an eight-byte value from the buffer object or string, at the given
offset, and returns it as an unsigned integer.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetuint64(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetfloat32
@section buffergetfloat32

Reads a four-byte IEEE floating point value from the buffer object or
string, at the given offset, and returns it as a number.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetfloat32(mybuffer, myoffset)
@end verbatim
@end example

@node functions-buffergetfloat64
@section buffergetfloat64

Reads an eight-byte IEEE floating point value from the buffer object or
string, at the given offset, and returns it as a number.
@bufferapifooter{}

@example lua
@verbatim
local num = bolt.buffergetfloat64(mybuffer, myoffset)
@end verbatim
@end example

@node Objects
@chapter List of Objects

This is a list of all types of userdata object used by the Bolt API. The
objects have various functions associated with them, all of which need
the userdata object as the first parameter. Lua has a shorthand for
this: for example, instead of @code{window.onresize(window, myhandler)},
you can write @code{window:onresize(myhandler)}.

@node objects-surface
@section Surface

A surface is a graphical canvas which can be drawn on with various
rendering functions, and can then be drawn to the user's screen by
calling @ref{surface-drawtoscreen}. The contents will
never be cleared, other than by explicitly calling @ref{surface-clear}.

Surface widths and heights should always be integral powers of 2. GPUs
often can't handle other values correctly which will result in
unexpected behaviour.

@node surface-clear
@subsection clear

Deletes any previous contents of the surface and sets it to contain a
single colour and alpha.

Takes up to four parameters in the range 0.0 - 1.0. All parameters to
this function are optional (apart from the surface itself). If none are
provided, the surface will be fully transparent. Otherwise, if alpha is
not provided, it will be assumed to be 1.0.

Note that if an alpha value less than 1 is provided, the
partially-transparent colour will still fully replace the old contents,
rather than blending with them.

@example lua
@verbatim
mysurface:clear() -- transparent
mysurface:clear(1, 0, 0) -- opaque red
mysurface:clear(1, 0, 0, 0.5) -- partially transparent red
@end verbatim
@end example

@node surface-subimage
@subsection subimage

Updates a rectangular section of this surface with the given RGBA pixel
data. The parameters are X, Y, width and height, in pixels, followed by
the RGBA data. The data can be either a string or a
@ref{objects-buffer}.

There are four bytes in an RGBA pixel, so the number of bytes in the
data is expected to be @code{4 * width * height}. If fewer bytes than
that are provided, the data will be padded with zeroes. If too many
bytes are provided, the excess data will be unused. The data will be
interpreted in row-major order with the first pixel being in the
top-left.

Note that non-opqaue pixels will fully replace the old contents of the
surface, rather than blending with them.

The following example sets the top-left pixel of a surface to a fully
opaque green colour:

@example lua
@verbatim
mysurface:subimage(0, 0, 1, 1, "\x00\x00\xFF\xFF")
@end verbatim
@end example

@node surface-drawtoscreen
@subsection drawtoscreen

Draws a section of the surface directly onto the screen. Parameters are
source X,Y,W,H followed by destination X,Y,W,H, all in pixels. Any
transparency will be blended additively and, if the size of the source
and destination rectangles is different, the image will be scaled
smoothly.

@example lua
@verbatim
mysurface:drawtoscreen(0, 0, 800, 608, 0, 0, 800, 608)
@end verbatim
@end example

@node surface-drawtosurface
@subsection drawtosurface

Draws a section of the surface onto a section of another surface.
Parameters are target surface, then source X,Y,W,H, then destination
X,Y,W,H, all in pixels. Any transparency will be blended additively and,
if the size of the source and destination rectangles is different, the
image will be scaled smoothly.

@example lua
@verbatim
mysurface:drawtosurface(myothersurface, 0, 0, 100, 100, 0, 0, 1920, 1080)
@end verbatim
@end example

@node surface-drawtowindow
@subsection drawtowindow

Draws a section of the surface onto a section of a @ref{objects-window}.
Parameters are target window, then source X,Y,W,H, then destination
X,Y,W,H, all in pixels. Any transparency will be blended additively and,
if the size of the source and destination rectangles is different, the
image will be scaled smoothly.

@example lua
@verbatim
mysurface:drawtowindow(mywindow, 0, 0, 100, 100, 0, 0, 1920, 1080)
@end verbatim
@end example

@node surface-settint
@subsection settint

Sets the "tint" this surface will be drawn with when drawing it to the
screen or to another surface. These values are in the range [0.0 - 1.0]
and are multiplied with the red, green and blue channels of the image,
so values less than 1.0 will darken the image. The defaults are all 1.0.

@example lua
@verbatim
mysurface:settint(red, green, blue)
@end verbatim
@end example

@node surface-setalpha
@subsection setalpha

Sets the alpha transparency this surface will be drawn with when drawing
it to the screen or to another surface. The value is in the range [0.0 -
1.0] where 0.0 is invisible and 1.0 is fully opaque. The default is 1.0.

@example lua
@verbatim
mysurface:setalpha(0.5)
@end verbatim
@end example

@node objects-buffer
@section Buffer

A buffer is a fixed-size, pre-allocated block of memory containing
binary data. Functions in Bolt which need binary data as an input can
take either a Lua string or a Buffer object. Functions that return
binary data return strings. The buffer API is designed to be mostly the
same as the @code{DataView} API in JavaScript, and exists to make it
easier to read and receive large amounts of raw binary data, such as
file contents, RGBA pixel data, or messages to and from browsers.

@example lua
@verbatim
local mybuffer = bolt.createbuffer(12)
mybuffer:setuint32(0, 12345)
mybuffer:setfloat64(4, -3.14159)
local num1 = mybuffer:getuint32(0) --returns 12345
local num2 = mybuffer:getfloat64(4) --returns -3.14159
@end verbatim
@end example

The "get" functions of buffers can be found on the base object returned
from @code{require("bolt")} and can be used on either strings or
buffers. For example, @ref{buffer-getuint32,,buffer:getuint32} is the
same as @ref{functions-buffergetuint32,,bolt.buffergetuint32}, except
that in the latter case, the buffer or string needs to be passed
explicitly as the first param. The buffer's "set" functions aren't
available by that method because strings are considered read-only.

@example lua
@verbatim
local mybuffer = bolt.createbuffer(4)
mybuffer:setuint32(0, 123)
local num1 = mybuffer:getuint32(0) --returns 123
local num2 = bolt.buffergetuint32(mybuffer, 0) --same function as above (except mybuffer could also have been a string)
@end verbatim
@end example

All functions in the buffer API are bounds-checked and will call
@code{error()} if the buffer size is exceeded, or if the given offset is
negative. However there are no limitations on memory alignment.

@example lua
@verbatim
local mybuffer = bolt.createbuffer(16)
mybuffer:setuin64(3, 123) --fine
mybuffer:setuin64(17, 0) --error (writing out of bounds)
@end verbatim
@end example

Endianness is always native. Values will be truncated as necessary using
C's type casts.

@node buffer-getint8
@subsection getint8

Reads a single byte from the buffer at the given offset and returns it
as a signed integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getint8(myoffset)
@end verbatim
@end example

@node buffer-getint16
@subsection getint16

Reads a two-byte value from the buffer at the given offset and returns
it as a signed integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getint16(myoffset)
@end verbatim
@end example

@node buffer-getint32
@subsection getint32

Reads a four-byte value from the buffer at the given offset and returns
it as a signed integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getint32(myoffset)
@end verbatim
@end example

@node buffer-getint64
@subsection getint64

Reads an eight-byte value from the buffer at the given offset and
returns it as a signed integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getint64(myoffset)
@end verbatim
@end example

@node buffer-getuint8
@subsection getuint8

Reads a single byte from the buffer at the given offset and returns it
as an unsigned integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getuint8(myoffset)
@end verbatim
@end example

@node buffer-getuint16
@subsection getuint16

Reads a two-byte value from the buffer at the given offset and returns
it as an unsigned integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getuint16(myoffset)
@end verbatim
@end example

@node buffer-getuint32
@subsection getuint32

Reads a four-byte value from the buffer at the given offset and returns
it as an unsigned integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getuint32(myoffset)
@end verbatim
@end example

@node buffer-getuint64
@subsection getuint64

Reads an eight-byte value from the buffer at the given offset and
returns it as an unsigned integer. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getuint64(myoffset)
@end verbatim
@end example

@node buffer-getfloat32
@subsection getfloat32

Reads a four-byte IEEE floating point value from the given offset and
returns it as a number. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getfloat32(myoffset)
@end verbatim
@end example

@node buffer-getfloat64
@subsection getfloat64

Reads an eight-byte IEEE floating point value from the given offset and
returns it as a number. @bufferapifooter{}

@example lua
@verbatim
local num = mybuffer:getfloat64(myoffset)
@end verbatim
@end example

@node buffer-setint8
@subsection setint8

Writes a single byte into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setint8(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setint16
@subsection setint16

Writes a two-byte value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setint16(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setint32
@subsection setint32

Writes a four-byte value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setint32(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setint64
@subsection setint64

Writes an eight-byte value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setint64(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setuint8
@subsection setuint8

Writes a single unsigned byte into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setuint8(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setuint16
@subsection setuint16

Writes a two-byte unsigned value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setuint16(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setuint32
@subsection setuint32

Writes a four-byte unsigned value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setuint32(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setuint64
@subsection setuint64

Writes an eight-byte unsigned value into the buffer at the given offset.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setuint64(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setfloat32
@subsection setfloat32

Writes a number into the buffer at the given offset, as a four-byte IEEE
floating-point value. @bufferapifooter{}

@example lua
@verbatim
mybuffer:setfloat32(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setfloat64
@subsection setfloat64

Writes a number into the buffer at the given offset, as an eight-byte
IEEE floating-point value. @bufferapifooter{}

@example lua
@verbatim
mybuffer:setfloat64(myoffset, myvalue)
@end verbatim
@end example

@node buffer-setstring
@subsection setstring

Writes a string into the buffer at the given offset. The entire string
will be copied. @bufferapifooter{}

@example lua
@verbatim
mybuffer:setstring(myoffset, mystring)
@end verbatim
@end example

@node buffer-setbuffer
@subsection setbuffer

Writes the contents of another buffer into this buffer at the given
offset. The entire contents of the source buffer will be copied.
@bufferapifooter{}

@example lua
@verbatim
mybuffer:setstring(myoffset, mystring)
@end verbatim
@end example

@node objects-window
@section Window

A window is a rectangle overlaid onto the game window. It has an
internal @ref{objects-surface} which can be rendered to and will be
automatically shown at the window's position. Windows also capture the
user's mouse and keyboard inputs and have callbacks which can be set to
handle those inputs.

The window will initially be transparent, but will still capture mouse
inputs, which will be visually confusing. Make sure to draw something to
the window after creating it when testing this function.

The window contents will be cleared when the window changes size, which
may happen for several reasons. Make sure to redraw in response to a
@ref{window-onreposition} if didresize is true, otherwise your window
will turn invisible.

@node window-close
@subsection close

Closes and destroys the window. This is the only way for a window to be
destroyed, other than the plugin stopping, which will destroy the window
automatically.

Do not use the window again after calling this function on it. No more
events will be received (although it is safe to call this from inside an
event handler.)

@example lua
@verbatim
mywindow:close()
@end verbatim
@end example

@node window-id
@subsection id

Returns an integer which uniquely identifies this window. No other
object will ever have this ID during this instance of the game process,
even if this plugin is stopped and started again.

@example lua
@verbatim
local id = mywindow:id()
@end verbatim
@end example

@node window-clear
@subsection clear

Deletes any previous contents of the window and sets it to contain a
single colour and alpha. @xref{surface-clear,,surface:clear}.

@node window-subimage
@subsection subimage

Updates a rectangular subsection of this window with the given RGBA
pixel data. @xref{surface-subimage,,surface:subimage}.

@node window-startreposition
@subsection startreposition

Starts repositioning for this window. This function changes how the
user's "drag" action is processed, and would usually be called from the
@ref{window-onmousebutton} callback for the left mouse button.
Repositioning will occur until the user releases the left mouse button
or until the repositioning is cancelled. In the first case, an
onreposition event will be fired (even if the size and position din't
actually change.) During repositioning, all mouse events will be handled
internally by the window, without calling its event handlers. The window
will not actually change size or position until repositioning ends by
the user releasing the mouse button.

This function takes two integer parameters. The first should be negative
if the window's left edge is being dragged, positive if the right edge
is being dragged, or zero if neither. The second should be negative if
the window's top edge is being dragged, positive if the bottom edge is
being dragged, or zero if neither. If both parameterss are zero then the
window will be moved instead of resized.

The following example would cause the window to be dragged by its
top-right edge:

@example lua
@verbatim
mywindow:startreposition(1, -1)
@end verbatim
@end example

@node window-cancelreposition
@subsection cancelreposition

Cancels repositioning for this window. The window's position and size
will not change and an onreposition event will not be sent.

@example lua
@verbatim
mywindow:cancelreposition()
@end verbatim
@end example

@node window-xywh
@subsection xywh

Returns the x, y, width and height of this window.

@example lua
@verbatim
local x, y, w, h = mywindow:xywh()
@end verbatim
@end example

@node window-onreposition
@subsection onreposition

@windoweventhandler{window, reposition events, @ref{objects-reposition}}

@example lua
@verbatim
mywindow:onreposition(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node window-onmousemotion
@subsection onmousemotion

@windoweventhandler{window, mouse motion events, @ref{objects-mousemotion}}

@example lua
@verbatim
mywindow:onmousemotion(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node window-onmousebutton
@subsection onmousebutton

@windoweventhandler{window, mouse button events, @ref{objects-mousebutton}}

This handler runs immediately after a button is pressed down. When the
button is released, @ref{window-onmousebuttonup} will run.

@example lua
@verbatim
mywindow:onmousebutton(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node window-onmousebuttonup
@subsection onmousebuttonup

@windoweventhandler{window, mouse button-up events, @ref{objects-mousebutton}}

This handler runs immediately after a button is released. It shares the
same type of event object as @ref{window-onmousebutton}. If the user
clicks the window and drags their mouse outside the window, the mouse
motion events and button-up will still usually be captured by the
window.

@example lua
@verbatim
mywindow:onmousebuttonup(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node window-onscroll
@subsection onscroll

@windoweventhandler{window, mouse scroll events, @ref{objects-scroll}}

@example lua
@verbatim
mywindow:onscroll(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node window-onmouseleave
@subsection onmouseleave

@windoweventhandler{window, mouse leave events, @ref{objects-mouseleave}}

@example lua
@verbatim
mywindow:onmouseleave(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node objects-browser
@section Browser

A browser object is a webview in an external OS-level window. It's a
chromium-based browser backed by CEF. The browser takes up the whole
window - there are no decorations like tabs or a URL bar or back button,
etc. The browser can navigate or fetch normal internet URLs via
@code{https://}, or files in the plugin directory with @code{plugin://}.
It can also request certain URLs at @code{https://bolt-api/} to
communicate with the Lua code running in the game process. Incoming
messages will be sent via the JavaScript @code{window.postMessage}
function.

@node browser-close
@subsection close

Closes and destroys the browser. This is the only way for a browser to
be destroyed, other than the plugin stopping, which will destroy the
browser automatically.

Do not use the browser again after calling this function on it. No more
events will be received (although it is safe to call this from inside an
event handler.)

@example lua
@verbatim
mybrowser:close()
@end verbatim
@end example

@node browser-sendmessage
@subsection sendmessage

Sends a message to the browser. The data can be either a string or a
@ref{objects-buffer}. It will be sent to the browser using the
postMessage function, so to handle it in your browser application, just
add an event listener for "message" to the window object. The event's
data will be an object with "type": "pluginMessage", and "content" will
be an ArrayBuffer containing the Lua string that was passed to this
function. Note that the binary data will be transferred exactly as it
appeared in Lua, byte-for-byte - it will not be decoded or re-encoded in
any way.

If this function is called immediately after creating the browser, it's
possible the message may arrive at the JavaScript process before the
page has actually loaded. In this case, Bolt will queue the message
until after the loading is complete. It's therefore safe to assume
plugin messages will never arrive before the 'DOMContentLoaded' event.

@example lua
@verbatim
mybrowser:sendmessage("some message contents")
@end verbatim
@end example

@node browser-enablecapture
@subsection enablecapture

Enables screen capture for this browser. The screen contents will be
sent to the browser using the postMessage function. The event's data
will be an object with "type": "screenCapture", "width" and "height"
will be integers indicating the size of the captured area, and "content"
will be an ArrayBuffer of length @code{width * height * 3}. The contents
will be three bytes per pixel, in RGB format, in row-major order,
starting with the bottom-left pixel.

The data will be sent using a shared memory mapping, so the overhead is
much lower than it would be to send all the data using sendmessage.
However, downloading screen contents from the GPU will still slow the
game down (takes around 2 to 5 milliseconds depending on window size),
so Bolt will limit itself to capturing 4 frames per second via this
function.

@example lua
@verbatim
mybrowser:enablecapture()
@end verbatim
@end example

@node browser-disablecapture
@subsection disablecapture

Disables screen capture for this browser. @xref{browser-enablecapture}.

@example lua
@verbatim
mybrowser:disablecapture()
@end verbatim
@end example

@node browser-showdevtools
@subsection showdevtools

Opens a chromium devtools window for this browser. If one is already
open, it will be focused instead of opening a new one. The devtools
window can't be closed through code, it can only be closed by a user
action (e.g. clicking the 'X') or by the browser itself closing.

@node browser-oncloserequest
@subsection oncloserequest

Sets an event handler for this browser for close-request events. The
function will overwrite any previous event handler, or, if it's not a
function, then any previous event handler will be deleted. Unlike most
event handlers, this one is called with no parameters.

Bolt takes no default action other than calling this function, which
means nothing will happen by default when the user tries to close the
browser. To enable normal closing behaviour, add a closerequest handler
which calls @code{mybrowser:close()}:

@example lua
@verbatim
mybrowser:oncloserequest(function ()
  mybrowser:close()
end)
@end verbatim
@end example

@node browser-onmessage
@subsection onmessage

Sets an event handler for this browser for message events. The function
will overwrite any previous event handler, or, if it's not a function,
then any previous event handler will be deleted. The function will be
called with a string as the only parameter. The string will contain the
binary data that was sent in the browser's POST message.

@example lua
@verbatim
mybrowser:onmessage(function (message)
  print(string.format("message received: %s", message))
end)
@end verbatim
@end example

Note that this example assumes that the message is safely formattable
text. This may or may not be the case, depending on what your browser's
web page is programmed to send.

@node objects-embeddedbrowser
@section Embedded Browser

An embedded browser object is a webview embedded into the game window.
It behaves similarly to a @ref{objects-window}, but with more state, and
most of the normal events of a Window object are handled internally by
the browser.

The browser is chromium-based, backed by CEF. The webview takes up the
whole rectangle - there are no decorations like tabs or a URL bar or
back button, etc. The browser can navigate or fetch normal internet URLs
via @code{https://}, or files in the plugin directory with
@code{plugin://}. It can also request certain URLs at
@code{https://bolt-api/} to communicate with the Lua code running in the
game process. Incoming messages will be sent via the JavaScript
@code{window.postMessage} function.

@node embeddedbrowser-close
@subsection close

Closes and destroys the browser. This is the only way for a browser to
be destroyed, other than the plugin stopping, which will destroy the
browser automatically.

Do not use the browser again after calling this function on it. No more
events will be received (although it is safe to call this from inside an
event handler.)

@example lua
@verbatim
mybrowser:close()
@end verbatim
@end example

@node embeddedbrowser-sendmessage
@subsection sendmessage

Sends a message to the browser. @xref{browser-sendmessage,,
browser:sendmessage}.

@node embeddedbrowser-startreposition
@subsection startreposition

Starts repositioning for this browser. @xref{window-startreposition,,
window:startreposition}.

@node embeddedbrowser-cancelreposition
@subsection cancelreposition

Cancels repositioning for this browser. @xref{window-cancelreposition,,
window:cancelreposition}.

@node embeddedbrowser-xywh
@subsection xywh

Returns the new x, y, width and height for this browser. @xref{window-xywh,,
window:xywh}.

@node embeddedbrowser-enablecapture
@subsection enablecapture

Enables screen capture for this browser. @xref{browser-enablecapture,,
browser:enablecapture}.

@node embeddedbrowser-disablecapture
@subsection disablecapture

Disables screen capture for this browser. @xref{browser-enablecapture,,
browser:enablecapture}.

@node embeddedbrowser-showdevtools
@subsection showdevtools

Opens a chromium devtools window for this browser. If one is already
open, it will be focused instead of opening a new one. The devtools
window can't be closed through code, it can only be closed by a user
action (e.g. clicking the 'X') or by the browser itself closing.

@node embeddedbrowser-oncloserequest
@subsection oncloserequest

Sets an event handler for this browser for close-request events. The
function will overwrite any previous event handler, or, if it's not a
function, then any previous event handler will be deleted. Unlike most
event handlers, this one is called with no parameters.

Bolt takes no default action other than calling this function, which
means nothing will happen by default when the user tries to close the
browser. To enable normal closing behaviour, add a closerequest handler
which calls @code{myembeddedbrowser:close()}:

@example lua
@verbatim
myembeddedbrowser:oncloserequest(function ()
  myembeddedbrowser:close()
end)
@end verbatim
@end example

@node embeddedbrowser-onmessage
@subsection onmessage

Sets an event handler for this browser for message events. The function
will overwrite any previous event handler, or, if it's not a function,
then any previous event handler will be deleted. The function will be
called with a string as the only parameter. The string will contain the
binary data that was sent in the browser's POST message.

@example lua
@verbatim
myembeddedbrowser:onmessage(function (message)
  print(string.format("message received: %s", message))
end)
@end verbatim
@end example

Note that this example assumes that the message is safely formattable
text. This may or may not be the case, depending on what your browser's
web page is programmed to send.

@node embeddedbrowser-onreposition
@subsection onreposition

@windoweventhandler{browser, reposition events, @ref{objects-reposition}}

@browserjavascriptevents{}

@example lua
@verbatim
mybrowser:onreposition(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node embeddedbrowser-onmousemotion
@subsection onmousemotion

@windoweventhandler{embeddedbrowser, mouse motion events, @ref{objects-mousemotion}}

@browserjavascriptevents{}

@example lua
@verbatim
mybrowser:onmousemotion(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node embeddedbrowser-onmousebutton
@subsection onmousebutton

@windoweventhandler{browser, mouse button events, @ref{objects-mousebutton}}

@browserjavascriptevents{}

This handler runs immediately after a button is pressed down. When the
button is released, @ref{embeddedbrowser-onmousebuttonup} will run.

@example lua
@verbatim
mybrowser:onmousebutton(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node embeddedbrowser-onmousebuttonup
@subsection onmousebuttonup

@windoweventhandler{browser, mouse button-up events, @ref{objects-mousebutton}}

@browserjavascriptevents{}

This handler runs immediately after a button is released. It shares the
same type of event object as @ref{embeddedbrowser-onmousebutton}. If the user
clicks the window and drags their mouse outside the window, the mouse
motion events and button-up will still usually be captured by the
window.

@example lua
@verbatim
mybrowser:onmousebuttonup(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node embeddedbrowser-onscroll
@subsection onscroll

@windoweventhandler{browser, mouse scroll events, @ref{objects-scroll}}

@browserjavascriptevents{}

@example lua
@verbatim
mybrowser:onscroll(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node embeddedbrowser-onmouseleave
@subsection onmouseleave

@windoweventhandler{browser, mouse leave events, @ref{objects-mouseleave}}

@browserjavascriptevents{}

@example lua
@verbatim
mybrowser:onmouseleave(function (event)
  -- ...
end)
@end verbatim
@end example

@eventobjectwarning{}

@node objects-point
@section Point

A Point object represents a point in 3D space. It's mainly useful for
doing transformation calculations with @ref{objects-transform}s, to
find, for example, the pixel coordinates on the user's screen where a
certain vertex is currently being rendered.

@node point-transform
@subsection transform

Transforms this Point by a Transform object and returns a new Point. The
original Point object is not modified.

@node point-get
@subsection get

Returns the X, Y and Z values for this point.

@node point-aspixels
@subsection aspixels

For a point that's been transformed into 3D screen space, this function
returns its X, Y, and depth. X and Y are in pixels with (0, 0) being the
top-left of the inner area of the game window. The the depth value is
logarithmic: -1.0 is very near the camera, 0.0 is about one tile away
from the camera, and +1.0 is the maximum render distance away from the
camera. Depth values outside that range indicate that the point is
probably behind the camera.

@example lua
@verbatim
local xpixel, ypixel, depth = mypoint:aspixels()
if depth >= -1.0 and depth <= 1.0 then
  -- pixel coordinates are valid, do something with them
end
@end verbatim
@end example

This is only useful for a point in world coordinates that has been
transformed by a @ref{render3d-viewprojmatrix} (or by a view and
projection matrix separately). In any other case the result will
probably not be meaningful.

To help with understanding everything this function does, here's an
equivalent Lua function with comments:

@example lua
@verbatim
local function aspixels(point)
  local x, y, z = point:get()

  -- get the X, Y, width and height of the 3D game view
  local gx, gy, gw, gh = bolt.gameviewxywh()

  -- x is in the range [-1.0, +1.0], so we need to map that range onto
  -- the game view, like so:
  local pixelx = ((x + 1.0) * gw / 2.0) + gx

  -- same as above, but we also need to invert y because GPUs think -1.0
  -- is the bottom of the screen, and we want points to be relative to
  -- the top-left, not the bottom-left
  local pixely = ((-y + 1.0) * gh / 2.0) + gy

  -- leave depth as-is
  return pixelx, pixely, z
end
@end verbatim
@end example

@node objects-transform
@section Transform

A transform represents a 4x4 transformation matrix. There's no way to
create a transform directly, they can only be obtained by querying
@ref{objects-render3d}s. They're useful for transforming points from
model coordinates into world coordinates or screen pixel coordinates.

@node transform-decompose
@subsection decompose

Decomposes the transform into the following nine constituent values, in
this order: X, Y, Z, in model coordinates; scale factor X, Y and Z;
yaw, pitch, roll, in radians.

Matrix decomposition is an experimental feature. It assumes the
right-most column of the matrix to be (0, 0, 0, 1). That will always be
the case in transforms returned by @ref{render3d-vertexanimation}, which
is the primary intended use of this function.

@example lua
@verbatim
local x, y, z, xscale, yscale, zscale, yaw, pitch, roll = mytransform:decompose()
@end verbatim
@end example

@node transform-get
@subsection get

Returns the 16 floating-point values that make up this transformation
matrix, in row-major order.

@example lua
@verbatim
local m1,  m2,  m3,  m4,
      m5,  m6,  m7,  m8,
      m9,  m10, m11, m12,
      m13, m14, m15, m16 = mytransform:get()
@end verbatim
@end example

@node objects-shader
@section Shader

A Shader object comes from @ref{functions-createvertexshader} or
@ref{functions-createfragmentshader}. Its only use is to pass to the
@ref{functions-createshaderprogram} function. The same shader may be
used to create any number of shader programs, but does not necessarily
need to be kept after creating the program(s). It's recommended to
delete unneeded shader objects to save memory.

@customshaderapifooter{object}

@node objects-shaderprogram
@section Shader Program

A Shader Program object comes from @ref{functions-createshaderprogram}.
It can be used to draw to surfaces using custom vertex and fragment
shaders.

@customshaderapifooter{object}

@node shaderprogram-setattribute
@subsection setattribute

Sets a shader attribute. This function is somewhat analogous to
glVertexAttribPointer, but not exactly the same. Firstly, this function
@strong{permanently} enables attribute @code{n} for the given program,
and it's an error to call this more than once for the same attribute
index for the same program. Secondly, the actual vertex data isn't
needed for this call, and is instead passed as a
@ref{objects-shaderbuffer} to the draw function. This means that, unlike
glVertexAttribPointer, this API requires all vertex data to be contained
in a single shader buffer.

This function requires seven parameters, as follows:
@enumerate
@item the attribute number
@item byte-size of each number in the input data, typically 1, 2, 4 or 8
@item "is_signed", a boolean indicating whether the input numbers are
signed (true) or unsigned (false)
@item "is_float", a boolean indicating whether the input numbers are
floats (true) or integers (false)
@item the number of numbers per attribute, e.g. 3 for a vec3 attribute
@item byte offset of the first attribute in the input data
@item stride, in bytes, between each attribute in the input data
@end enumerate

Valid byte sizes for floats are 2, 4 and 8, and valid byte sizes for
integers are 1, 2, or 4. An invalid byte size will cause this function
to call @code{error()}. It will also call @code{error()} if is_signed is
false and is_float is true.

@example lua
@verbatim
-- enable attribute 0 to read float32 values, three per attribute,
-- beginning at byte 0 of the buffer and stepping forward by 12 bytes per attribute
myprogram:setattribute(0, 4, true, false, 3, 0, 12)
@end verbatim
@end example

@node shaderprogram-setuniform1i
@subsection setuniform1i

Sets one integer as a uniform value. The first param is the "location"
specified in GLSL and the second is the value. This value will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform1i(location, myinteger)
@end verbatim
@end example

@node shaderprogram-setuniform2i
@subsection setuniform2i

Sets two integers as a uniform value. The first param is the "location"
specified in GLSL and the rest are the values. These values will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform2i(location, myint1, myint2)
@end verbatim
@end example

@node shaderprogram-setuniform3i
@subsection setuniform3i

Sets three integers as a uniform value. The first param is the
"location" specified in GLSL and the rest are the values. These values
will be permanently associated with this location for this program,
until it's overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform3i(location, myint1, myint2, myint3)
@end verbatim
@end example

@node shaderprogram-setuniform4i
@subsection setuniform4i

Sets four integers as a uniform value. The first param is the "location"
specified in GLSL and the rest are the values. These values will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform4i(location, myint1, myint2, myint3, myint4)
@end verbatim
@end example

@node shaderprogram-setuniform1f
@subsection setuniform1f

Sets one float as a uniform value. The first param is the "location"
specified in GLSL and the second is the value. This value will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform1f(location, mynumber)
@end verbatim
@end example

@node shaderprogram-setuniform2f
@subsection setuniform2f

Sets two floats as a uniform value. The first param is the "location"
specified in GLSL and the rest are the values. These values will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform2f(location, mynum1, mynum2)
@end verbatim
@end example

@node shaderprogram-setuniform3f
@subsection setuniform3f

Sets three floats as a uniform value. The first param is the "location"
specified in GLSL and the rest are the values. These values will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform3f(location, mynum1, mynum2, mynum3)
@end verbatim
@end example

@node shaderprogram-setuniform4f
@subsection setuniform4f

Sets four floats as a uniform value. The first param is the "location"
specified in GLSL and the rest are the values. These values will be
permanently associated with this location for this program, until it's
overwritten by another setuniform call.

@example lua
@verbatim
myprogram:setuniform4f(location, mynum1, mynum2, mynum3, mynum4)
@end verbatim
@end example

@node shaderprogram-setuniformmatrix2f
@subsection setuniformmatrix2f

Sets four floats as a uniform mat2x2 value. The first param is the
"location" specified in GLSL, the second is the "transpose" boolean, and
the rest are the values. Transposing a matrix turns it from row-major to
column-major or vice versa. These values will be permanently associated
with this location for this program, until it's overwritten by another
setuniform call.

@example lua
@verbatim
myprogram:setuniformmatrix2f(location, false, n11, n21, n12, n22)
@end verbatim
@end example

@node shaderprogram-setuniformmatrix3f
@subsection setuniformmatrix3f

Sets nine floats as a uniform mat3x3 value. The first param is the
"location" specified in GLSL, the second is the "transpose" boolean, and
the rest are the values. Transposing a matrix turns it from row-major to
column-major or vice versa. These values will be permanently associated
with this location for this program, until it's overwritten by another
setuniform call.

@example lua
@verbatim
myprogram:setuniformmatrix3f(location, false, n11, n21, n31, n12, n22, n32, n13, n23, n33)
@end verbatim
@end example

@node shaderprogram-setuniformmatrix4f
@subsection setuniformmatrix4f

Sets 16 floats as a uniform mat4x4 value. The first param is the
"location" specified in GLSL, the second is the "transpose" boolean, and
the rest are the values. Transposing a matrix turns it from row-major to
column-major or vice versa. These values will be permanently associated
with this location for this program, until it's overwritten by another
setuniform call.

In the following example, the 16 values are returned from
@ref{transform-get}, taking advantage of the Lua feature where multiple
return values can be used implicitly as multiple function arguments:

@example lua
@verbatim
myprogram:setuniformmatrix4f(location, false, mytransform:get())
@end verbatim
@end example

@node shaderprogram-setuniformsurface
@subsection setuniformsurface

Sets a @ref{objects-surface} as a uniform value. This will usually be
used for uniform sampler2D variables. This value will be permanently
associated with this location for this program, until it's overwritten
by another setuniform call. Note that if the surface is destroyed before
being used for a render, the results will be undefined, so make sure to
keep your surface object in scope for as long as it remains bound to any
uniforms.

@example lua
@verbatim
myprogram:setuniformsurface(location, mysurface)
@end verbatim
@end example

@node shaderprogram-drawtosurface
@subsection drawtosurface

Invokes this shader program to draw to a surface. Parameters are the
target surface, a shader buffer, and an integer indicating the number of
vertices to draw. Each 3 vertices will make a triangle. If the number of
vertices isn't a multiple of 3, then the last 1 or 2 will usually be
ignored.

@node objects-shaderbuffer
@section Shader Buffer

This is not to be confused with @ref{objects-buffer}. The difference is
that Buffer objects exist in RAM and can be read from or written to at
any time. Shader Buffer objects exist in VRAM, cannot be read from, and
cannot be written to after creation, but can be used to run custom
shader programs.

@customshaderapifooter{object}

@node objects-batch2d
@section Batch2D Event

A Batch2D event comes from @ref{functions-onrender2d}. or
@ref{functions-onminimaprender2d}. It occurs when the game draws a batch
of 2D icons to the screen, or to the minimap image. 2D icon renders are
uploaded to the GPU in batches rather than one-at-a-time, so to look for
an individual image, you'll need to iterate through each individual
image in the batch, by iterating through the vertices. The number of
vertices per image is usually 6 (i.e. two polygons) but it's recommended
to call @ref{batch2d-verticesperimage} to get this number instead of
hard-coding it into your plugin.

A Batch2D will only ever have one texture associated with it - a large
surface, usually 8192x8192, with a lot of rectangular images on it. This
is commonly called a "texture atlas". Each vertex has associated data
which points to a rectangular section of that texture. This can be
queried to find the exact pixel contents of the image being drawn.

When querying vertex data, keep in mind that Lua indices start at 1, so
the valid range is 1 to vertexcount, inclusive:

@example lua
@verbatim
for i = 1, event:vertexcount() do
-- ...
@end verbatim
@end example

@eventobjectwarning{}

@node batch2d-vertexcount
@subsection vertexcount

Returns the number of vertices in a 2D batch object. Divide by
@ref{batch2d-verticesperimage} to get the number of icons being
rendered.

@node batch2d-verticesperimage
@subsection verticesperimage

Returns the number of vertices per individual image in this batch. At
time of writing, this will always return 6 (i.e. enough to draw two
separate triangles). To future-proof against possible engine updates,
it's recommended to use this function instead of hard-coding the number
6 into your plugin.

@node batch2d-targetsize
@subsection targetsize

Returns the width and height of the target area of this render, in
pixels.

For a miminap render event, this will be the size of the minimap image,
usually 256x256. For a normal render2d event, this will be proportional
to the size of the inner area of the game window, given by
@ref{functions-gamewindowsize} - that is, if the user has an interface
scaling other than 100%, it will be bigger or smaller than that area,
proportionally.

@node batch2d-vertexxy
@subsection vertexxy

Given an index of a vertex in a batch, returns its X and Y position on
the screen, in pixel coordinates. As with all screen coordinates in the
Bolt API, this is relative to the top-left pixel of the screen.

@node batch2d-vertexatlasdetails
@subsection vertexatlasdetails

Given an index of a vertex in a batch, returns six values describing the
vertex's image in the dexture atlas. The first four values are the x, y,
width and height, in pixels. The fifth and six values are booleans which
relate to U and V coordinates respectively: if the value is true, U or V
coordinates which fall outside the sub-image should wrap around within
it. If the value is false, values should instead be clamped to the edges
of the sub-image.

@node batch2d-vertexuv
@subsection vertexuv

Given an index of a vertex in a batch, returns the vertex's associated
"UV" coordinates. The values will either be floating-point numbers in
the range 0.0 - 1.0, or nil.

If either of the returned values is nil, then the texture data for this
vertex should be ignored and RGBA values of 1.0 should be used instead.
Otherwise, the UVs are relative to the entire texture atlas, but may be
outside of the sub-image rectangle. See
@xref{batch2d-vertexatlasdetails} to see how to handle those cases.

@node batch2d-vertexcolour
@subsection vertexcolour

Given an index of a vertex in a batch, returns the red, green, blue and
alpha values for that vertex, in that order. All four values will be
floating-point numbers in the range 0.0 - 1.0.

These values are multiplied with the texture, so values less than 1.0
will darken the texture. A common use for this is to draw coloured text.

@node batch2d-vertexcolor
@subsection vertexcolor

Alias for @ref{batch2d-vertexcolour}

@node batch2d-textureid
@subsection textureid

Returns the unique ID of the texture associated with this render. There
will always be one (and only one) texture atlas associated with a 2D
render batch.

The plugin API does not have a way to get a texture by its ID; this is
intentional, as it wouldn't always be safe to do so. The purpose of this
function is to be able to compare texture IDs together to check if the
current texture is the same one that was used in a previous render.

@node batch2d-texturesize
@subsection texturesize

Returns the size of the overall texture atlas associated with this
batch, in pixels.

@node batch2d-texturecompare
@subsection texturecompare

Compares a section of the texture atlas for this batch to some RGBA
pixel data. The data can be a string or a @ref{objects-buffer}. The
function will return true only if the bytes are an exact match. It
internally uses memcmp from the C library. This means comparing each set
of contiguous data is very fast, but, since the data needs to be
contiguous, it can only be checked one row at a time.

Internally, Bolt compares against data taken from the CPU just before
being uploaded to the GPU, so there will never be any imprecision issues
caused by different GPUs/drivers/etc.

The example below checks if the pixels at x,y and (x+1),y are fully
opaque and red.

@example lua
@verbatim
mybatch:texturecompare(x, y, "\xFF\x00\x00\xFF\xFF\x00\x00\xFF")
@end verbatim
@end example

Normally the X and Y coordinates should be calculated from
@ref{batch2d-vertexatlasdetails}.

@node batch2d-texturedata
@subsection texturedata

Gets the RGBA data starting at a given coordinate of the texture atlas,
and returns it as a Lua string.

The following example would return an 8-bytes-long string, containing
the RGBA data for two pixels.

@example lua
@verbatim
mybatch:texturedata(x, y, 8)
@end verbatim
@end example

Using this function to search for specific textures isn't recommended as
it would be noticeably slower than using @ref{batch2d-texturecompare}.

@node objects-render3d
@section Render3D Event

A Render3D event comes from @ref{functions-onrender3d}. It
occurs when a 3D model is rendered to the game view. All of the model's
vertex coordinates and texture data can be queried, along with its
animation data if the model is animated.

Bolt has a complex set of functions for doing calculations with 3D space
data. Render3D's @ref{render3d-vertexpoint} function returns static
model data which will always be the same for two instances of the same
model even if they're placed differently, scaled or rotated differently,
doing different animations, etc. To get the model's position in world
space, use @ref{render3d-modelmatrix}:

@example lua
@verbatim
local modelpoint = myevent:vertexpoint(1)
local worldpoint = modelpoint:transform(myevent:modelmatrix())
@end verbatim
@end example

This gives an X, Y and Z in world coordinates, which can be used to find
its position on the world map. From there, you can use its
@ref{render3d-viewprojmatrix} to find where it will appear on the user's
screen, in pixel coordinates:

@example lua
@verbatim
local pixelx, pixely = worldpoint:transform(myevent:viewprojmatrix()):aspixels()
@end verbatim
@end example

This will give the pixel coordinates at which a static vertex would be
rendered. If the model is animated, you might like to apply its
animation data to the transform to get the vertex's true position. Each
vertex in an animated model has an animation transform associated with
it. An animation transform is from model-space to model-space, so it
must be applied before any of the other transforms.

@example lua
@verbatim
local modelpoint = myevent:vertexpoint(1)
local animatedpoint = modelpoint:transform(myevent:vertexanimation(1))
local worldpoint = animatedpoint:transform(myevent:modelmatrix())
@end verbatim
@end example

Like Batch2D events, Render3D events always have exactly one texture
atlas associated with them, but each vertex may be textured with a
different section of that atlas. Unlike Batch2D however, there's an
extra step involved in getting the pixel data associated with a vertex.
The vertex's meta-id must be queried with @ref{render3d-vertexmeta},
then pass the meta-id to @ref{render3d-atlasxywh} to get the correct
section of the texture atlas:

@example lua
@verbatim
local mymeta = event:vertexmeta(1)
local x, y, w, h = event:atlasxywh(mymeta)
@end verbatim
@end example

When querying vertex data, keep in mind that Lua indices start at 1, so
the valid range is 1 to vertexcount, inclusive:

@example lua
@verbatim
for i = 1, event:vertexcount() do
-- ...
@end verbatim
@end example

@eventobjectwarning{}

@node render3d-vertexcount
@subsection vertexcount

Returns the number of vertices in a model.

@example lua
@verbatim
local count = event:vertexcount()
@end verbatim
@end example

@node render3d-vertexpoint
@subsection vertexpoint

Given a vertex number, returns a @ref{objects-point} representing the
vertex's model coordinates, according to the static model data.

@example lua
@verbatim
local modelpoint = event:vertexpoint(1)
@end verbatim
@end example

@node render3d-modelmatrix
@subsection modelmatrix

Returns the @ref{objects-transform} representing the model matrix of the
model being rendered. This can be used to transform points from model
coordinates into world coordinates.

@example lua
@verbatim
local modelmatrix = event:modelmatrix()
local modelpoint = event:vertexpoint(1)
local worldpoint = modelpoint:transform(modelmatrix)
@end verbatim
@end example

@node render3d-viewmatrix
@subsection viewmatrix

Returns the @ref{objects-transform} representing the view matrix of the
model being rendered. Unless you understand the difference between a
view matrix and a projection matrix, this probably isn't useful to you;
@ref{render3d-viewprojmatrix} can be used to more efficiently get a
transform from world coordinates to pixel coordinates.

@node render3d-projectionmatrix
@subsection projectionmatrix

Returns the @ref{objects-transform} representing the projection matrix
of the model being rendered. Unless you understand the difference
between a view matrix and a projection matrix, this probably isn't
useful to you; @ref{render3d-viewprojmatrix} can be used to more
efficiently get a transform from world coordinates to pixel coordinates.

@node render3d-viewprojmatrix
@subsection viewprojmatrix

Returns the @ref{objects-transform} representing the combined view and
projection matrices, commonly called the "viewproj matrix", of the model
being rendered. This can be used to transform points from world
coordinates into screen coordinates.

@node render3d-vertexmeta
@subsection vertexmeta

Given a vertex number, returns a meta-ID (an integer) relating to its
associated texture image. This can then be passed to
@ref{render3d-atlasxywh}.

@example lua
@verbatim
local meta = event:vertexmeta(1)
local x, y, w, h = event:atlasxywh(meta)
@end verbatim
@end example

@node render3d-atlasxywh
@subsection atlasxywh

Given a vertex number, returns the X, Y, width and height of its
associated image in the texture atlas, in pixel coordinates.

@example lua
@verbatim
local meta = event:vertexmeta(1)
local x, y, w, h = event:atlasxywh(meta)
@end verbatim
@end example

@node render3d-vertexuv
@subsection vertexuv

Given a vertex number, returns the vertex's associated "UV" coordinates.

The values will be floating-point numbers, usually in the range 0.0 -
1.0. They are relative to image in the texture atlas. They may fall
outside the image (and therefore outside the range 0.0 - 1.0), in which
case they're expected to wrap around within the image.

@node render3d-vertexcolour
@subsection vertexcolour

Given a vertex number, returns the red, green, blue and alpha values for
that vertex, in that order. All four values will be floating-point
numbers in the range 0.0 - 1.0.

These values are multiplied with the texture, so values less than 1.0
will darken the texture (or make it more transparent in the case of the
alpha channel). A common use for this is to draw differently "tinted"
versions of the same model using the same texture.

@node render3d-vertexcolor
@subsection vertexcolor

Alias for @ref{render3d-vertexcolour}

@node render3d-textureid
@subsection textureid

Returns the unique ID of the texture associated with this render. There
will always be one (and only one) texture atlas associated with a 3D
render.

The plugin API does not have a way to get a texture by its ID; this is
intentional, as it wouldn't always be safe to do so. The purpose of this
function is to be able to compare texture IDs together to check if the
current texture is the same one that was used in a previous render.

@node render3d-texturesize
@subsection texturesize

Returns the size of the overall texture atlas associated with this
batch, in pixels.

@node render3d-texturecompare
@subsection texturecompare

Compares a section of the texture atlas for this batch to some RGBA
pixel data. The data can be a string or a @ref{objects-buffer}. The
function will return true only if the bytes are an exact match. It
internally uses memcmp from the C library. This means comparing each set
of contiguous data is very fast, but, since the data needs to be
contiguous, it can only be checked one row at a time.

Internally, Bolt compares against data taken from the CPU just before
being uploaded to the GPU, so there will never be any imprecision issues
caused by different GPUs/drivers/etc.

The example below checks if the pixels at x,y and (x+1),y are fully
opaque and red.

@example lua
@verbatim
event:texturecompare(x, y, "\xFF\x00\x00\xFF\xFF\x00\x00\xFF")
@end verbatim
@end example

Normally the X and Y coordinates should be calculated from
@ref{render3d-atlasxywh}.

@node render3d-texturedata
@subsection texturedata

Gets the RGBA data starting at a given coordinate of the texture atlas,
and returns it as a Lua string.

The following example would return an 8-bytes-long string, containing
the RGBA data for two pixels.

@example lua
@verbatim
mybatch:texturedata(x, y, 8)
@end verbatim
@end example

Using this function to search for specific textures isn't recommended as
it would be noticeably slower than using @ref{render3d-texturecompare}.

@node render3d-vertexanimation
@subsection vertexanimation

Given a vertex number, returns the Transform object that would be
applied to its static model, in model coordinates, to transform it into
its current animated position.

It's a fatal error to call this function on a render event for a
non-animated model, since non-animated models have no bone transforms
that could be queried. To check if the model is animated, use
@ref{render3d-animated}.

@node render3d-animated
@subsection animated

Returns a boolean value indicating whether this model is animated.
Animated models can have multiple bones which can move independently of
each other. If this function returns false, then the model has no
animation data, and calling @ref{render3d-vertexanimation} will result
in an error.

@example lua
@verbatim
if event:animated() then
  -- it's safe to call event:vertexanimation
end
@end verbatim
@end example

@node objects-renderparticles
@section Render Particles Event

A render-particles event comes from @ref{functions-onrenderparticles}.
It occurs when a set of particles from one or more particle emitters are
rendered to the 3D game view. Render-particles events are fairly similar
to render3d events in the way textures and transforms work, with one big
difference: the world position of a particle vertex cannot be queried
directly. Instead, plugins can query the world position the particle a
vertex belongs to, using the @ref{renderparticles-vertexparticleorigin}
function. If a plugin really needs to know the positioning of each
individual vertex, it will need to apply two offsets to that position:
the 3D offset given by @ref{renderparticles-vertexworldoffset}, which is
added directly to the world position, and the 2D offset given by
@ref{renderparticles-vertexeyeoffset}, which is added in eye-space, i.e.
relative to the direction the camera is facing, for billboarding.

@example lua
@verbatim
bolt.onrenderparticles(function (event)
  for i = 1, event:vertexcount() do
    -- view and projection matrix
    local viewmatrix = event:viewmatrix()
    local projmatrix = event:projmatrix()
    
    -- the world position of this particle
    local x, y, z = event:vertexparticleorigin(i):get()

    -- world offset of this individual vertex of the particle
    local wx, wy, wz = event:vertexworldoffset(i)

    -- eye offset of this individual vertex of the particle
    local ex, ey = event:vertexeyeoffset(i)

    -- apply transforms and offsets in the correct order:
    local eyepoint = bolt.point(x + wx, y + wy, z + wz):transform(viewmatrix)
    local eyex, eyey, eyez = eyepoint:get()
    local screenpoint = bolt.point(eyex + ex, eyey + ey, eyez):transform(projmatrix)
    local xpixel, ypixel, depth = screenpoint:aspixels()
  end
end)
@end verbatim
@end example

@node renderparticles-vertexcount
@subsection vertexcount

Returns the number of vertices being rendered.

@example lua
@verbatim
local count = event:vertexcount()
@end verbatim
@end example

@node renderparticles-vertexparticleorigin
@subsection vertexparticleorigin

Given a vertex number, returns a @ref{objects-point} representing the
position of the particle that the vertex belongs to, in world
coordinates. All vertices of a particle will have the same origin, since
they all belong to the same particle.

@example lua
@verbatim
local worldpoint = event:vertexparticleorigin(i)
@end verbatim
@end example

@node renderparticles-vertexworldoffset
@subsection vertexworldoffset

Given a vertex number, returns three numbers representing the X, Y and Z
offset of that vertex from the particle's origin, in world space. See
@ref{objects-renderparticles} for more info on offsets.

@example lua
@verbatim
local xoffset, yoffset, zoffset = event:vertexworldoffset(i)
@end verbatim
@end example

@node renderparticles-vertexeyeoffset
@subsection vertexeyeoffset

Given a vertex number, returns two numbers representing the X and Y
offset of that vertex from the particle's origin, in eye-space (i.e.
relative to the direction the camera is facing, for billboarding.) See
@ref{objects-renderparticles} for more info on offsets.

@example lua
@verbatim
local xoffset, yoffset = event:vertexeyeoffset(i)
@end verbatim
@end example

@node renderparticles-vertexuv
@subsection vertexuv

Given a vertex number, returns the vertex's associated "UV" coordinates.

The values will be floating-point numbers, usually in the range 0.0 -
1.0. They are relative to image in the texture atlas. They may fall
outside the image (and therefore outside the range 0.0 - 1.0), in which
case they're expected to wrap around within the image.

@node renderparticles-vertexcolour
@subsection vertexcolour

Given a vertex number, returns the red, green, blue and alpha values for
that vertex, in that order. All four values will be floating-point
numbers in the range 0.0 - 1.0.

These values are multiplied with the texture, so values less than 1.0
will darken the texture (or make it more transparent in the case of the
alpha channel). A common use for this is to draw differently "tinted"
versions of the same type of particle using the same texture.

@node renderparticles-vertexcolor
@subsection vertexcolor

Alias for @ref{renderparticles-vertexcolour}

@node renderparticles-vertexmeta
@subsection vertexmeta

Given a vertex number, returns a meta-ID (an integer) relating to its
associated texture image. This can then be passed to
@ref{renderparticles-atlasxywh}.

@example lua
@verbatim
local meta = event:vertexmeta(1)
local x, y, w, h = event:atlasxywh(meta)
@end verbatim
@end example

@node renderparticles-atlasxywh
@subsection atlasxywh

Given a vertex number, returns the X, Y, width and height of its
associated image in the texture atlas, in pixel coordinates.

@example lua
@verbatim
local meta = event:vertexmeta(1)
local x, y, w, h = event:atlasxywh(meta)
@end verbatim
@end example

@node renderparticles-textureid
@subsection textureid

Returns the unique ID of the texture associated with this render. There
will always be one (and only one) texture atlas associated with a
particle render.

The plugin API does not have a way to get a texture by its ID; this is
intentional, as it wouldn't always be safe to do so. The purpose of this
function is to be able to compare texture IDs together to check if the
current texture is the same one that was used in a previous render.

@node renderparticles-texturesize
@subsection texturesize

Returns the size of the overall texture atlas associated with this
render, in pixels.

@node renderparticles-texturecompare
@subsection texturecompare

Compares a section of the texture atlas for this batch to some RGBA
pixel data. The data can be a string or a @ref{objects-buffer}. The
function will return true only if the bytes are an exact match. It
internally uses memcmp from the C library. This means comparing each set
of contiguous data is very fast, but, since the data needs to be
contiguous, it can only be checked one row at a time.

Internally, Bolt compares against data taken from the CPU just before
being uploaded to the GPU, so there will never be any imprecision issues
caused by different GPUs/drivers/etc.

The example below checks if the pixels at x,y and (x+1),y are fully
opaque and red.

@example lua
@verbatim
event:texturecompare(x, y, "\xFF\x00\x00\xFF\xFF\x00\x00\xFF")
@end verbatim
@end example

@node renderparticles-texturedata
@subsection texturedata

Gets the RGBA data starting at a given coordinate of the texture atlas,
and returns it as a Lua string.

The following example would return an 8-bytes-long string, containing
the RGBA data for two pixels.

@example lua
@verbatim
mybatch:texturedata(x, y, 8)
@end verbatim
@end example

Using this function to search for specific textures isn't recommended as
it would be noticeably slower than using
@ref{renderparticles-texturecompare}.

@node renderparticles-viewmatrix
@subsection viewmatrix

Returns a @ref{objects-transform} representing the view matrix being
used for this particle render.

@node renderparticles-projmatrix
@subsection projmatrix

Returns a @ref{objects-transform} representing the projection matrix
being used for this particle render.

@node renderparticles-inverseviewmatrix
@subsection inverseviewmatrix

Returns a @ref{objects-transform} representing the inverse of the view
matrix (a.k.a. the camera matrix) for this particle render. This can be
used to transform points from eye-space to world-space.

@node objects-rendericon
@section Render Icon Event

A render-icon event comes from @ref{functions-onrendericon} or
@ref{functions-onrenderbigicon}. It occurs when a pre-rendered icon is
drawn to the game view. Icons refer to items appearing in the UI, such
as the player's inventory, equipment screen, or action bar slots. These
appear to be 2D images but in reality they're pre-rendered "snapshots"
of the item's 3D models, which can make them very difficult to work with
compared to a normal 2D image. Bolt attempts to simplify this by storing
some of the details of the models rendered at the time when the icon is
created, and allows plugins to query this stored data. However this
means that some data is missing compared to a Render3D event; most
notably, the texture data is currently not saved.

An icon may contain any number of models, and each vertex in each model
may be queried using the functions of this event.

@example lua
@verbatim
bolt.onrendericon(function (event)
  for model = 1, event:modelcount() do
    for vertex = 1, event:modelvertexcount(model) do
      let point = event:modelvertexpoint(model, vertex)
      -- ...
    end
  end
end)
@end verbatim
@end example

The view and projection matrix used when pre-rendering the item can also
be queried for each model. There's no model matrix for this process, so
the model coordinates are treated as if they were the world coordinates.
Some items, especially most weapons' off-hand variants, use the same
item model viewed from a different camera angle, which means the only
way to differentiate between them is to @ref{transform-decompose} the
view matrix.

@eventobjectwarning{}

@node rendericon-xywh
@subsection xywh

Returns the x, y, width and height of where this icon is being drawn on
the screen, in pixel coordinates. The X and Y are relative to the
top-left pixel of the inner area of the window.

@example lua
@verbatim
local x, y, width, height = event:xywh()
@end verbatim
@end example

@node rendericon-modelcount
@subsection modelcount

Returns the number of 3D models that were rendered to this icon.

@example lua
@verbatim
for model = 1, event:modelcount() do
  -- ...
end
@end verbatim
@end example

@node rendericon-modelvertexcount
@subsection modelvertexcount

Given a model index, returns the number of vertices in that model.

@example lua
@verbatim
for model = 1, event:modelcount() do
  for vertex = 1, event:modelvertexcount(model) do
    -- ...
  end
end
@end verbatim
@end example

@node rendericon-modelvertexpoint
@subsection modelvertexpoint

Given a model number and vertex number, returns a @ref{objects-point}
representing the vertex's model coordinates.

@example lua
@verbatim
local point = event:modelvertexpoint(model, vertex)
@end verbatim
@end example

@node rendericon-modelvertexcolour
@subsection modelvertexcolour

Given a model number and a vertex number, returns the red, green, blue
and alpha values for that vertex, in that order. All four values will be
floating-point numbers in the range 0.0 - 1.0.

These values are multiplied with the texture, so values less than 1.0
will darken the texture (or make it more transparent in the case of the
alpha channel). A common use for this is to draw differently "tinted"
versions of the same model using the same texture.

@example lua
@verbatim
local red, green, blue, alpha = event:modelvertexcolour(model, vertex)
@end verbatim
@end example

@node rendericon-modelvertexcolor
@subsection modelvertexcolor

Alias for @ref{rendericon-modelvertexcolour}

@node rendericon-targetsize
@subsection targetsize

Returns the width and height of the target area of this render, in
pixels.

This will be proportional to the size of the inner area of the game
window, given by @ref{functions-gamewindowsize} - that is, if the user
has an interface scaling other than 100%, it will be bigger or smaller
than that area, proportionally.

@example lua
@verbatim
local width, height = event:targetsize()
@end verbatim
@end example

@node rendericon-modelviewmatrix
@subsection modelviewmatrix

Given a model number, returns a @ref{objects-transform} representing the
view matrix that was used to render it.

@example lua
@verbatim
local viewmatrix = event:modelviewmatrix(model)
@end verbatim
@end example

@node rendericon-modelprojectionmatrix
@subsection modelprojectionmatrix

Given a model number, returns a @ref{objects-transform} representing the
projection matrix that was used to render it.

@example lua
@verbatim
local projmatrix = event:modelprojectionmatrix(model)
@end verbatim
@end example

@node rendericon-modelviewprojmatrix
@subsection modelviewprojmatrix

Given a model number, returns a @ref{objects-transform} representing the
combined view and projection matrices, commonly called the "viewproj
matrix", that was used to render that model. These are pre-multiplied
in the shader, so using the viewproj matrix is more efficient than using
the view and projection matrices separately.

@example lua
@verbatim
local viewprojmatrix = event:modelviewprojmatrix(model)
@end verbatim
@end example

@node rendericon-colour
@subsection colour

Returns the red, green, blue and alpha values that this icon is being
rendered with. These values are multiplied with the texture, so values
less than 1.0 will darken the icon (or make it more transparent in the
case of the alpha channel). This is usually used to draw transparent or
"tinted" versions of the same pre-rendered icon. For example, a
placeholder item in your bank will be drawn slightly transparent, even
though the icon itself is non-transparent, to indicate that the item is
a placeholder and not an actual item.

@example lua
@verbatim
local red, green, blue, alpha = event:colour()
@end verbatim
@end example

@node rendericon-color
@subsection color

Alias for @ref{rendericon-colour}

@node objects-minimapterrain
@section Minimap Terrain Event

A Minimap Terrain event comes from @ref{functions-onminimapterrain}. It
occurs when the background terrain gets drawn to the minimap image,
which usually happens once per frame, unless the minimap isn't visible.
The terrain can't be inspected directly, but this event can be queried
for some useful information, like the angle the minimap is rotated to
and the world position it's centered on.

@eventobjectwarning{}

@node minimapterrain-angle
@subsection angle

Returns the angle at which the minimap background image is being
rendered, in radians. The angle is 0 when upright (facing directly
north), and increases counter-clockwise (note that turning the camera
clockwise rotates the minimap counter-clockwise and vice versa).

@node minimapterrain-scale
@subsection scale

Returns the scale at which the minimap background image is being
rendered. This indicates how far in or out the minimap is zoomed. It
appears to be capped between roughly 0.5 and 3.5.

@node minimapterrain-position
@subsection position

Returns an estimate of the X and Y position the minimap is centered on,
in world coordinates. This is only a rough estimate and can move around
a lot even while standing still. It usually doesn't vary by more than
half a tile.

@node objects-renderminimap
@section Render Minimap Event

A render minimap event comes from @ref{functions-onrenderminimap}. It
occurs when the minimap image gets drawn to the game window, which
usually happens once per frame, unless the minimap isn't visible. This
event can be used to find out the location of the minimap on the user's
screen. To get the minimap contents, see @ref{objects-minimapterrain}
and @ref{functions-onminimaprender2d}.

@eventobjectwarning{}

@node renderminimap-sourcexywh
@subsection xywh

Returns the x, y, width and height of the section of the minimap image
being drawn, in pixels.

@example lua
@verbatim
local x, y, width, height = event:sourcexywh()
@end verbatim
@end example

@node renderminimap-targetxywh
@subsection xywh

Returns the x, y, width and height of where the minimap is being drawn
on the screen, in pixel coordinates. The X and Y are relative to the
top-left pixel of the inner area of the window.

@example lua
@verbatim
local x, y, width, height = event:targetxywh()
@end verbatim
@end example

@node renderminimap-targetsize
@subsection targetsize

Returns the width and height of the target area of this render, in
pixels.

This will be proportional to the size of the inner area of the game
window, given by @ref{functions-gamewindowsize} - that is, if the user
has an interface scaling other than 100%, it will be bigger or smaller
than that area, proportionally.

@example lua
@verbatim
local width, height = event:targetsize()
@end verbatim
@end example

@node objects-swapbuffers
@section SwapBuffers event

A SwapBuffers event comes from @ref{functions-onswapbuffers}. It occurs
at the end of a frame (and the beginning of a new frame), so anywhere
from 5 to 200+ times per second depending on the user's FPS. It's
commonly used as a "sync point", i.e. to ensure that some Lua code will
run at regular intervals. The event object is a userdata but has no
functions.

Unlike other events in the Bolt API, which fire immediately after the
event in question has happened, SwapBuffers events fire immediately
before the buffers are actually swapped. This means any rendering done
in a SwapBuffers event will be immediately visible on the current frame.

@eventobjectwarning{}

@node objects-reposition
@section Reposition Event

A Reposition event comes from @ref{window-onreposition}. It indicates
that the size or position of a @ref{objects-window} has changed. This
could happen for several reasons, such as the game window being resized,
so never assume that it won't happen.

@ref{reposition-didresize} can be used to check if the window size
changed. If it did, the window contents have been cleared to transparent
and must be redrawn.

@eventobjectwarning{}

@node reposition-xywh
@subsection xywh

Returns the new x, y, width and height that the window was repositioned
to.

@example lua
@verbatim
local newx, newy, newwidth, newheight = event:xywh()
@end verbatim
@end example

@node reposition-didresize
@subsection didresize

Returns a boolean value indicating whether the window changed size. If
true, the contents of the window were cleared and need to be redrawn.

@example lua
@verbatim
if event:didresize() then
  -- re-draw something to the window
end
@end verbatim
@end example

@node objects-mousemotion
@section Mouse Motion Event

A Mouse Motion event comes from @ref{functions-onmousemotion,,
bolt.onmousemotion} or @ref{window-onmousemotion,,window:onmousemotion}.
It occurs when the mouse moves while inside the game window. Each window
or embedded browser can only receive one mouse motion event per frame -
the latest position will always be sent, but some position updates in
between will be dropped. The same goes for @ref{functions-onmousemotion,
,bolt.onmousemotion}.

@eventobjectwarning{}

@node mousemotion-xy
@subsection xy

Returns the x and y for this mouse event in pixels, relative to the
top-left of the window that it relates to.

@example lua
@verbatim
local x, y = event:xy()
@end verbatim
@end example

@node mousemotion-ctrl
@subsection ctrl

Returns a boolean value indicating whether @code{ctrl} was held when
this event was fired.

@example lua
@verbatim
local ctrl = event:ctrl()
@end verbatim
@end example

@node mousemotion-shift
@subsection shift

Returns a boolean value indicating whether @code{shift} was held when
this event was fired.

@example lua
@verbatim
local shift = event:shift()
@end verbatim
@end example

@node mousemotion-meta
@subsection meta

Returns a boolean value indicating whether the meta key (also known as
super, command, or the "windows key") was held when this event was
fired.

@example lua
@verbatim
local meta = event:meta()
@end verbatim
@end example

@node mousemotion-alt
@subsection alt

Returns a boolean value indicating whether @code{alt} was held when this
event was fired.

@example lua
@verbatim
local alt = event:alt()
@end verbatim
@end example

@node mousemotion-capslock
@subsection capslock

Returns a boolean value indicating whether caps lock was on when this
event was fired.

@example lua
@verbatim
local capslock = event:capslock()
@end verbatim
@end example

@node mousemotion-numlock
@subsection numlock

Returns a boolean value indicating whether numlock was on when this
event was fired.

@example lua
@verbatim
local numlock = event:numlock()
@end verbatim
@end example

@node mousemotion-mousebuttons
@subsection mousebuttons

Returns three boolean values indicating whether each primary mouse
button was held when this event fired, in the order: left, right,
middle.

@example lua
@verbatim
local lmb, rmb, mmb = event:buttons()
@end verbatim
@end example

@node objects-mousebutton
@section Mouse Button Event

A Mouse Button event comes from @ref{functions-onmousebutton,,
bolt.onmousebutton}, @ref{functions-onmousebuttonup,,
bolt.onmousebuttonup}, @ref{window-onmousebutton,,
window:onmousebutton}, or @ref{window-onmousebuttonup,,
window:onmousebuttonup}. It occurs when one of the three primary mouse
buttons is pressed or released. The action of pressing a mouse button
will be captured by the window or embedded browser under the mouse at
the time. In the case of the left mouse button, the button-up event will
usually be captured by the window that was clicked on, as well as any
mouse motion events that happen between the press and release.

@eventobjectwarning{}

@node mousebutton-xy
@subsection xy

Returns the x and y for this mouse event in pixels, relative to the
top-left of the window that it relates to.

@example lua
@verbatim
local x, y = event:xy()
@end verbatim
@end example

@node mousebutton-ctrl
@subsection ctrl

Returns a boolean value indicating whether @code{ctrl} was held when
this event was fired.

@example lua
@verbatim
local ctrl = event:ctrl()
@end verbatim
@end example

@node mousebutton-shift
@subsection shift

Returns a boolean value indicating whether @code{shift} was held when
this event was fired.

@example lua
@verbatim
local shift = event:shift()
@end verbatim
@end example

@node mousebutton-meta
@subsection meta

Returns a boolean value indicating whether the meta key (also known as
super, command, or the "windows key") was held when this event was
fired.

@example lua
@verbatim
local meta = event:meta()
@end verbatim
@end example

@node mousebutton-alt
@subsection alt

Returns a boolean value indicating whether @code{alt} was held when this
event was fired.

@example lua
@verbatim
local alt = event:alt()
@end verbatim
@end example

@node mousebutton-capslock
@subsection capslock

Returns a boolean value indicating whether caps lock was on when this
event was fired.

@example lua
@verbatim
local capslock = event:capslock()
@end verbatim
@end example

@node mousebutton-numlock
@subsection numlock

Returns a boolean value indicating whether numlock was on when this
event was fired.

@example lua
@verbatim
local numlock = event:numlock()
@end verbatim
@end example

@node mousebutton-mousebuttons
@subsection mousebuttons

Returns three boolean values indicating whether each primary mouse
button was held when this event fired, in the order: left, right,
middle.

@example lua
@verbatim
local lmb, rmb, mmb = event:buttons()
@end verbatim
@end example

@node mousebutton-button
@subsection button

Returns an integer representing the mouse button that was pressed or
released. Possible values are 1 for the left mouse button, 2 for the
right mouse button, and 3 for the middle mouse button (clicking the
mouse wheel).

@node objects-scroll
@section Scroll Event

A Scroll event comes from @ref{functions-onscroll,,bolt.onscroll} or
@ref{window-onscroll,,window:onscroll}. It occurs when the user scrolls
their mouse wheel while the mouse is inside the game window.

@eventobjectwarning{}

@node scroll-xy
@subsection xy

Returns the x and y for this mouse event in pixels, relative to the
top-left of the window that it relates to.

@example lua
@verbatim
local x, y = event:xy()
@end verbatim
@end example

@node scroll-ctrl
@subsection ctrl

Returns a boolean value indicating whether @code{ctrl} was held when
this event was fired.

@example lua
@verbatim
local ctrl = event:ctrl()
@end verbatim
@end example

@node scroll-shift
@subsection shift

Returns a boolean value indicating whether @code{shift} was held when
this event was fired.

@example lua
@verbatim
local shift = event:shift()
@end verbatim
@end example

@node scroll-meta
@subsection meta

Returns a boolean value indicating whether the meta key (also known as
super, command, or the "windows key") was held when this event was
fired.

@example lua
@verbatim
local meta = event:meta()
@end verbatim
@end example

@node scroll-alt
@subsection alt

Returns a boolean value indicating whether @code{alt} was held when this
event was fired.

@example lua
@verbatim
local alt = event:alt()
@end verbatim
@end example

@node scroll-capslock
@subsection capslock

Returns a boolean value indicating whether caps lock was on when this
event was fired.

@example lua
@verbatim
local capslock = event:capslock()
@end verbatim
@end example

@node scroll-numlock
@subsection numlock

Returns a boolean value indicating whether numlock was on when this
event was fired.

@example lua
@verbatim
local numlock = event:numlock()
@end verbatim
@end example

@node scroll-mousebuttons
@subsection mousebuttons

Returns three boolean values indicating whether each primary mouse
button was held when this event fired, in the order: left, right,
middle.

@example lua
@verbatim
local lmb, rmb, mmb = event:buttons()
@end verbatim
@end example

@node scroll-direction
@subsection direction

Returns a boolean value representing the scroll direction. False means
scrolling down, toward the user, and true means scrolling up, away from
the user.

@example lua
@verbatim
local direction = event:direction()
@end verbatim
@end example

@node objects-mouseleave
@section Mouse Leave Event

A Mouse Leave event comes from @ref{window-onmouseleave,,
window:onmouseleave}. It occurs when the user moves their mouse such
that it's no longer inside the window or embedded browser.

@eventobjectwarning{}

@node mouseleave-xy
@subsection xy

Returns the x and y for this mouse event in pixels, relative to the
top-left of the window that it relates to.

@example lua
@verbatim
local x, y = event:xy()
@end verbatim
@end example

@node mouseleave-ctrl
@subsection ctrl

Returns a boolean value indicating whether @code{ctrl} was held when
this event was fired.

@example lua
@verbatim
local ctrl = event:ctrl()
@end verbatim
@end example

@node mouseleave-shift
@subsection shift

Returns a boolean value indicating whether @code{shift} was held when
this event was fired.

@example lua
@verbatim
local shift = event:shift()
@end verbatim
@end example

@node mouseleave-meta
@subsection meta

Returns a boolean value indicating whether the meta key (also known as
super, command, or the "windows key") was held when this event was
fired.

@example lua
@verbatim
local meta = event:meta()
@end verbatim
@end example

@node mouseleave-alt
@subsection alt

Returns a boolean value indicating whether @code{alt} was held when this
event was fired.

@example lua
@verbatim
local alt = event:alt()
@end verbatim
@end example

@node mouseleave-capslock
@subsection capslock

Returns a boolean value indicating whether caps lock was on when this
event was fired.

@example lua
@verbatim
local capslock = event:capslock()
@end verbatim
@end example

@node mouseleave-numlock
@subsection numlock

Returns a boolean value indicating whether numlock was on when this
event was fired.

@example lua
@verbatim
local numlock = event:numlock()
@end verbatim
@end example

@node mouseleave-mousebuttons
@subsection mousebuttons

Returns three boolean values indicating whether each primary mouse
button was held when this event fired, in the order: left, right,
middle.

@example lua
@verbatim
local lmb, rmb, mmb = event:buttons()
@end verbatim
@end example

@node browser-apis
@chapter Browser APIs

Browser objects and embedded browser objects have access to a few APIs
which are primarily used for communicating with the Lua code running in
the game process. Incoming messages will be via the JavaScript
@code{window.postMessage} function, so can be handled like so:

@example js
@verbatim
window.addEventListener('message', async (event) => {
  if (typeof(event.data) !== "object") return;
  // check event.data.type...
});
@end verbatim
@end example

APIs invoked by the web page itself are accessed by making a web request
to @code{https://bolt-api/}, as shown in the examples for the relevant
API endpoints.

Browsers and embedded browsers have no @code{window.close()} function,
as one would usually find in JavaScript in a web page. This function
doesn't work correctly in CEF so it has been disabled. Pages that want
to self-close must use the @ref{browserapis-close-request} API instead.

@node browserapis-pluginmessage
@section pluginMessage

A message has been received from the Lua sendmessage function being
called on this Browser or Embedded Browser object.
@code{event.data.content} is an ArrayBuffer containing the binary data
that was passed to the function. This type of message will never arrive
before the initial 'DOMContentLoaded' event for the page, as Bolt will
queue them until after the page has completely loaded.

@example js
@verbatim
window.addEventListener('message', async (event) => {
  if (typeof(event.data) !== "object") return;
  if (event.data.type === "pluginMessage") {
    const message = (new TextDecoder()).decode(event.data.content);
    console.log(message);
  }
});
@end verbatim
@end example

Note that this example assumes that the message is safely formattable
text. This may or may not be the case, depending on what your plugin is
programmed to send.

@node browserapis-screencapture
@section screenCapture

Screen capture is currently enabled for this browser, and a new screen
capture has been received. @code{event.data.width} and
@code{event.data.height} are the width and height of the image in
pixels, and @code{event.data.content} is an ArrayBuffer of length
@code{width * height * 3}, containing the RGB pixel data.

@example js
@verbatim
window.addEventListener('message', async (event) => {
  if (typeof(event.data) !== "object") return;
  if (event.data.type === "screenCapture") {
    console.log(`got screen capture ${event.data.width}x${event.data.height}`);
    // do something with event.data.content...
  }
});
@end verbatim
@end example

@node browserapis-send-message
@section /send-message

A POST to this URL will result in an onmessage event being fired for the
relevant browser object or embedded browser object in Lua. The POST body
will be sent as-is, byte-for-byte, without being decoded or re-encoded
in any way.

@example js
@verbatim
fetch("https://bolt-api/send-message", {method: 'POST', body: 'some message contents'});
@end verbatim
@end example

@node browserapis-close-request
@section /close-request

A request to this URL will result in an oncloserequest event being fired
for the browser object in Lua, as if the user had clicked the 'X' button
on the window. This doesn't actually close the window; if the Lua object
has no event handler for close requests then nothing will happen.

@example js
@verbatim
fetch("https://bolt-api/close-request");
@end verbatim
@end example

@node browserapis-start-reposition
@section /start-reposition

@xref{embeddedbrowser-startreposition}. The query should contain two
params, "h" and "v", for the horizontal and vertical components,
respectively. This should usually be done in response to a JavaScript
onmousedown event for the left mouse button. This has no effect on
Browser objects, which are not embedded into the game window.

The following example would cause the window to be dragged by its
top-right edge:

@example js
@verbatim
fetch("https://bolt-api/start-reposition?h=1&v=-1");
@end verbatim
@end example

@node browserapis-cancel-reposition
@section /cancel-reposition

@xref{embeddedbrowser-cancelreposition}. This has no effect on Browser
objects, which are not embedded into the game window.

@example js
@verbatim
fetch("https://bolt-api/cancel-reposition");
@end verbatim
@end example

@node browserapis-showdevtools
@section /show-devtools

Opens a chromium devtools window for this browser. If one is already
open, it will be focused instead of opening a new one. The devtools
window can't be closed through code, it can only be closed by a user
action (e.g. clicking the 'X') or by the browser itself closing.

@node appendix-custom-shaders
@appendix Appendix: custom shader API

The custom shader API allows rendering to surfaces using custom vertex
and fragment shaders and custom vertex data. It's very powerful, but
requires some prior understanding of shader programming to be able to
use it.

Custom shaders must be written in GLSL. Here's how to compile a vertex
shader object and fragment shader object using GLSL code:

@example lua
@verbatim
local vs = bolt.createvertexshader(
  "layout(location=0) in highp vec2 pos;"..
  "out highp vec2 vpos;"..
  "void main() {"..
    "vpos = pos;"..
    "gl_Position = vec4(pos, 0.0, 1.0);"..
  "}"
)
local fs = bolt.createfragmentshader(
  "in highp vec2 vpos;"..
  "out highp vec4 col;"..
  "void main() {"..
    "col = vec4((vpos + 1.0) / 2.0, 1.0, 1.0);"..
  "}"
)
@end verbatim
@end example

Of course, these strings may come from anywhere, you don't necessarily
have to write them inline if you don't want to. Note the absence of a
@code{#version} header in these shaders. The Bolt API automatically
prepends @code{#version 330 core} to your code, so you mustn't include
a version header yourself. Lastly be aware that the plugin will be
terminated by a call to @code{error()} if shader compilation fails, so
you'll need to read stdout to find out the reason.

Next, create a shader program by linking your shaders:

@example lua
@verbatim
local program = bolt.createshaderprogram(vs, fs)
@end verbatim
@end example

Again, this function will call @code{error()} if linking fails, such as
if you provided two vertex shaders or two fragment shaders.

Since we no longer need the shader objects, we should delete them to
save memory. As with all userdata objects, custom deletion logic (in
this case, glDeleteShader) is handled by Lua's garbage collector.

@example lua
@verbatim
vs = nil
fs = nil
@end verbatim
@end example

Next, we need to set up our program's attributes by calling
@ref{shaderprogram-setattribute} on it. This function permanently
associates values with the attribute in question, so it only needs to be
called once, usually right after creation. The vertex shader defined
above has only one input attribute at @code{location=0}, so we'll
activate attribute 0 and leave the others inactive.

@example lua
@verbatim
program:setattribute(0, 1, true, false, 2, 0, 2)
@end verbatim
@end example

There are a lot of parameters here, so let's take them one at a time:
@itemize @minus
@item the first param is 0 because of @code{layout(location=0)}.
@item the second param is 1 because we'll be putting 1-byte integers
into our shader buffer.
@item the third param is true to indicate that the integers are signed.
@item the fourth param is false to indicate that the numbers are
integers, not floating-point values.
@item the fifth param is 2 because there are two items per attribute,
because the attribute is defined as a vec2 in the GLSL code.
@item the sixth param is 0 because the first attribute will be found at
byte 0 of the data.
@item the last param is 2 because the stride between each attribute in
the data will be 2 bytes.
@end itemize

By the way, there's no way to query attribute locations by name, so
using @code{layout(location=...)} in your GLSL code is required to be
able to pass data in. The same goes for uniform variables. The behaviour
of attributes or uniforms with overlapping memory regions is undefined
in Bolt, so don't do it.

You'll notice we defined the format of our data, but we don't actually
have any data yet. The format of each attribute is defined in the shader
program, but the data itself doesn't need to exist yet - it's passed in
when calling a draw function. Here we'll create a shader buffer that
contains six signed 1-byte integers - that's three vertices with one
vec2 per vertex.

@example lua
@verbatim
local buf = bolt.createbuffer(6)

-- vec2 of the first vertex
buf:setint8(0, -1)
buf:setint8(1, -1)

-- vec2 of the second vertex
buf:setint8(2, 1)
buf:setint8(3, -1)

--vec2 of the third vertex
buf:setint8(4, 1)
buf:setint8(5, 1)

local myshaderbuffer = bolt.createshaderbuffer(buf)
@end verbatim
@end example

Once again, keep in mind that earlier we told our program to expect
vertex data with a 1-byte signed integer per value, two values per
vertex, the first set being at byte 0, and increasing by two bytes for
each vertex. Now we've formatted our input data in a way that matches
that description.

The points (-1, -1), (1, -1), and (1, 1) make a right-angled triangle
with the right angle at the bottom-right, so it'll be easy to see if
it's worked correctly.

The @ref{functions-createshaderbuffer} function creates a shader buffer
by uploading the given data to the GPU, after which it can't be read or
written anymore. Here we used a @ref{objects-buffer} to write the data
before sending it. Don't be misled here: a buffer object is not the same
thing as a shader buffer object. @xref{objects-shaderbuffer} for an
explanation.

Now we are ready to run our shader. Let's create a surface and draw to
it using our program and buffer.

@example lua
@verbatim
local mysurface = bolt.createsurface(100, 100)
program:drawtosurface(mysurface, myshaderbuffer, 3)
@end verbatim
@end example

Finally, to be able to see our surface, let's draw it to the screen in a
swapbuffers callback.

@example lua
@verbatim
bolt.onswapbuffers(function (event)
  mysurface:drawtoscreen(0, 0, 100, 100, 100, 100, 200, 200)
end)
@end verbatim
@end example

If you did everything right, here's what you'll see on your screen:

@image{appendix-custom-shaders-1,,,custom shader triangle,.png}

That's almost right. But didn't we say that the right-angle should be at
the bottom-right, not the top-right? Why is our triangle upside-down?
Well, this is because we drew to a surface, and the surface is
correcting this for us. GPUs use -1.0 to refer to the bottom of the
screen and +1.0 to refer to the top, but the Bolt API wants to work the
other way round, with 0 being the top and @code{screen_height} being the
bottom. @code{drawtoscreen} is correcting for this by drawing the image
upside-down when we specify y=100 and height=200. This is a notable
"gotcha" to be aware of when working with custom shaders.

@node appendix-world-coordinates
@appendix Appendix: note on world coordinates

Some of the Render3D and Minimap functions refer to "world coordinates".
These refer to an actual position in the world, at a scale of 512 units
per tile.

@itemize @bullet
@item The X coordinate is west-to-east, increasing when travelling east
and decreasing when travelling west.
@item The Y coordinate is height, increasing upwards and decreasing
downwards.
@item The Z coordinate is south-to-north, increasing when travelling
north and decreasing when travelling south.
@end itemize

Coordinate (X=0, Z=0) is the southwest corner of a tile. A model that's
at the center of a tile, such as an idle player or NPC, will have X and
Z coordinates ending in @code{.5}.

@bye
